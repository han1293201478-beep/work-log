<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>å¤œç­å·¥æ—¶åˆè§„æ£€æŸ¥å™¨ï¼ˆAI å¯¹è¯å¢å¼ºç‰ˆï¼‰</title>
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
  <style>
    body { font-family: "Microsoft YaHei", sans-serif;
padding: 20px; background-color: #f9f9f9; }
    .container { max-width: 1000px; margin: 0 auto; background: white; padding: 20px;
border-radius: 10px; box-shadow: 0 0 10px rgba(0,0,0,0.1); }
    h1, h2, h3 { color: #333;
}
    h1 { text-align: center; }
    
    /* === å±…ä¸­æ ·å¼ä¿®æ”¹ === */
    .nav-tabs { 
        text-align: center; 
        margin-bottom: 20px; 
    }
    .month-picker, 
    .import-export, 
    .view-toggle {
        text-align: center;
        margin-top: 15px; 
        margin-bottom: 15px; 
    }

    .nav-tabs button { margin: 0 6px;
padding: 6px 12px; border: 1px solid #ccc; background: #f5f5f5; cursor: pointer; border-radius: 4px;
}
    .nav-tabs button.active { background: #1890ff; color: white; border-color: #1890ff;
}
    .calendar { display: grid; gap: 4px; margin-top: 10px; }
    .day-header { text-align: center;
font-weight: bold; padding: 6px; background: #eee; border-radius: 4px; font-size: 14px; }
    .day-cell { height: 80px; display: flex;
flex-direction: column; align-items: center; justify-content: center; border: 1px solid #ddd; border-radius: 4px; cursor: pointer; background: #fff; font-size: 14px; user-select: none;
position: relative; padding: 4px; text-align: center; }
    .day-number { font-weight: bold;
}
    .day-hours { font-size: 12px; color: #666; margin-top: 2px; }
    .day-extra { font-size: 11px;
color: #999; }
    .day-total { font-size: 11px; color: #d46b08; font-weight: bold; margin-top: 2px;
}
    .day-cell.over-limit { box-shadow: 0 0 0 3px red;
}
    .day-cell.multi-selected { outline: 2px solid blue; z-index: 2;
}
    .controls button { margin: 5px; padding: 8px 12px; border: none; border-radius: 4px; cursor: pointer; font-size: 14px;
}
    .btn-sync { background: #52c41a; color: white; }
    .shift-info { margin-top: 20px; padding: 15px;
background: #f0f9ff; border-radius: 6px; }
    .result { margin-top: 10px; padding: 8px; border-radius: 4px; font-weight: bold;
}
    .ok { background: #f6ffed; color: #52c41a; }
    .warn { background: #fff2f0; color: #ff4d4f;
}
    .week-summary { margin-top: 20px; }
    .week-list { max-height: 300px; overflow-y: auto;
border: 1px solid #eee; border-radius: 6px; padding: 10px; background: #fafafa; }
    .week-item { padding: 6px 0;
border-bottom: 1px solid #f0f0f0; font-size: 14px; }
    .week-item.violation { background: #fff2f0; color: #ff4d4f; font-weight: bold;
}
    
    /* ... (å…¶ä»– CSS æ ·å¼ä¿æŒä¸å˜) ... */
    .day-cell:hover { background: #e6f7ff; }
    .day-cell.selected-big { background: #ffe58f; border-color: #faad14; }
    .day-cell.selected-small { background: #b7eb8f; border-color: #52c41a; }
    .day-cell.custom { background: #ffd6e7; border-color: #eb2f96; }
    .btn-big { background: #faad14; color: white; }
    .btn-small { background: #52c41a; color: white; }
    .btn-clear { background: #d9d9d9; color: black; }
    .btn-delete { background: #ff4d4f; color: white; }
    .btn-extra { background: #722ed1; color: white; }
    .btn-settings { background: #13c2c2; color: white; }
    
    .modal { display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.5); z-index: 3000; justify-content: center; align-items: center; }
    .modal-content { background: white; padding: 20px; border-radius: 8px; width: 320px; text-align: left; }
    .modal h3 { text-align: center; margin-top: 0; }
    .modal input, .modal select { width: 100%; padding: 8px; margin: 10px 0; border: 1px solid #ccc; border-radius: 4px; box-sizing: border-box; }
    .modal-buttons { text-align: center; margin-top: 15px; }
    .modal-buttons button { margin: 0 8px; }
    #importFileInput { display: none; }
    .panel { display: none; }
    .panel.active { display: block; }
    .settings-grid, .stats-controls, .stats-grid { display: grid; gap: 15px; margin-top: 15px; }
    .settings-grid { grid-template-columns: repeat(auto-fill, minmax(220px, 1fr)); }
    .setting-item, .stat-item { padding: 12px; background: #fafafa; border-radius: 6px; border: 1px solid #eee; }
    .setting-item label { display: block; margin-bottom: 6px; font-weight: bold; font-size: 14px; }
    .setting-item input, .setting-item select { width: 100%; padding: 6px; border: 1px solid #ccc; border-radius: 4px; }
    .stat-value { font-size: 20px; font-weight: bold; color: #1890ff; margin-top: 6px; }
    .stats-controls, .chat-controls { display: grid; gap: 15px; margin-top: 15px; grid-template-columns: 1fr 1fr auto; align-items: end; }
    .stats-controls > div, .chat-controls > div { display: flex; flex-direction: column; }
    .stats-controls label, .chat-controls label { font-size: 14px; margin-bottom: 4px; }
    .stats-controls input[type="date"], .chat-controls input[type="date"] { padding: 6px; border: 1px solid #ccc; border-radius: 4px; }
    .stats-controls button, .chat-controls button { height: 34px; margin-top: 22px; }
    #chartContainer { margin-top: 20px; position: relative; height: 300px; }
    .selection-mode-indicator { background: #1890ff; color: white; padding: 6px 12px; border-radius: 4px; font-size: 14px; display: inline-block; }
    .sync-status { display: inline-flex; align-items: center; gap: 8px; padding: 4px 10px; border-radius: 4px; font-size: 14px; margin-left: 10px; transition: all 0.3s ease; }
    .sync-status.synced { background: #f6ffed; color: #52c41a; }
    .sync-status.syncing { background: #e6f7ff; color: #1890ff; animation: pulse 1.5s infinite; }
    .sync-status.error { background: #fff2f0; color: #ff4d4f; }
    .sync-status.warning { background: #fff7e6; color: #d46b08; }
    @keyframes pulse { 0%, 100% { opacity: 0.8; } 50% { opacity: 1; } }
    
    /* ä¿®å¤ AI Chat å¸ƒå±€: ç¡®ä¿èŠå¤©è®°å½•å‚ç›´å †å  */
    #chatContainer { display: flex; flex-direction: column; height: 600px; border: 1px solid #ddd; border-radius: 8px; overflow: hidden; margin-top: 15px; }
    .ai-chat-history { 
        flex-grow: 1; 
        overflow-y: auto; 
        padding: 15px; 
        background-color: #f7f7f7; 
        border: 1px solid #ddd; 
        border-radius: 8px 8px 0 0; 
        min-height: 200px; 
        max-height: 400px; 
        margin-top: 10px; 
        display: none; /* é»˜è®¤éšè— */
    }
    .ai-chat-history.visible {
        display: flex; /* å˜ä¸ºå¯è§æ—¶ä½¿ç”¨ Flex */
        flex-direction: column; /* å…³é”®ï¼šå‚ç›´å †å æ¶ˆæ¯ */
    }

    #chatHistory { flex-grow: 1; overflow-y: auto; padding: 15px; background-color: #f7f7f7; }
    .chat-message { padding: 10px 15px; margin-bottom: 10px; border-radius: 18px; max-width: 90%; line-height: 1.6; }
    .chat-user { align-self: flex-end; margin-left: auto; background-color: #1890ff; color: white; border-bottom-right-radius: 2px; }
    .chat-ai { align-self: flex-start; margin-right: auto; background-color: #e6e6e6; color: #333; border-bottom-left-radius: 2px; }
    .chat-ai pre { white-space: pre-wrap; background: #fff; padding: 10px; border-radius: 4px; border: 1px dashed #ccc; font-size: 12px; margin-top: 5px; overflow-x: auto; }
    .ai-chat-input-container { padding: 10px 15px; background-color: white; border: 1px solid #ddd; border-top: none; border-radius: 0 0 8px 8px; display: flex; gap: 10px; }
    .ai-chat-input-container textarea { flex-grow: 1; padding: 8px; border: 1px solid #ccc; border-radius: 12px; resize: none; max-height: 80px; line-height: 1.4; }
    .ai-chat-input-container button { background-color: #52c41a; color: white; border: none; padding: 8px 15px; border-radius: 12px; cursor: pointer; font-weight: bold; }
    #chatInputContainer { padding: 15px; background-color: white; border-top: 1px solid #ddd; display: flex; }
    #chatInput { flex-grow: 1; padding: 10px; border: 1px solid #ccc; border-radius: 20px; margin-right: 10px; resize: none; }
    #chatSendBtn { background-color: #52c41a; color: white; border: none; padding: 10px 20px; border-radius: 20px; cursor: pointer; font-weight: bold; }
    #chatSendBtn:disabled { background-color: #ccc; cursor: not-allowed; }
  </style>
</head>
<body>
  <div class="container">
    <h1>
      å¤œç­å·¥æ—¶åˆè§„æ£€æŸ¥å™¨ï¼ˆAI å¯¹è¯å¢å¼ºç‰ˆï¼‰
      <span id="syncStatus" class="sync-status synced">âœ“ å·²åŒæ­¥</span>
    </h1>

    <div class="nav-tabs">
      <button id="tab-calendar" class="active" onclick="switchTab('calendar')">æ—¥å†</button>
      <button id="tab-stats" onclick="switchTab('stats')">ğŸ“Š ç»Ÿè®¡åˆ†æ</button>
      <button id="tab-chat" onclick="switchTab('chat')">ğŸ’¬ AI å¯¹è¯</button>
      <button id="tab-settings" onclick="switchTab('settings')">âš™ï¸ è®¾ç½®</button>
    </div>

    <div id="panel-calendar" class="panel active">
      <div class="month-picker">
        <label>é€‰æ‹©æœˆä»½ï¼š</label>
        <input type="month" id="monthInput" />
        <button onclick="renderCalendar()">ç¡®å®š</button>
        <button class="btn-settings" onclick="forceLoad()">ğŸ“¥ ä»äº‘ç«¯åŠ è½½</button>
        <button class="btn-sync" onclick="forceUpload()">ğŸ“¤ ç«‹å³ä¸Šä¼ </button>
      </div>

      <div class="import-export">
        <button onclick="exportData()">ğŸ“¤ å¯¼å‡ºå¤‡ä»½ï¼ˆJSONï¼‰</button>
        <button onclick="document.getElementById('importFileInput').click()">ğŸ“¥ æ‰‹åŠ¨å¯¼å…¥</button>
        <input type="file" id="importFileInput" accept=".json" onchange="importData(event)" />
        <p style="font-size:12px;color:#666;margin-top:6px;">
          â˜ï¸ æ•°æ®è‡ªåŠ¨äº‘ç«¯åŒæ­¥ |
âœ“ ç¦»çº¿å¯ç”¨ | ID: <span id="userIdDisplay"></span>
        </p>
      </div>

      <div class="view-toggle">
        <button id="btn-week" class="active" onclick="switchView('week')">æ ‡å‡†å‘¨å†ï¼ˆ7å¤©/å‘¨ï¼‰</button>
        <button id="btn-cycle" onclick="switchView('cycle')">6å¤©å¾ªç¯å†</button>
      </div>

      <div class="controls">
        <p id="multiSelectHint">â€¢ PCç«¯ï¼šæŒ‰ä½ **Ctrl/Cmd** é”®ç‚¹å‡»æ—¥æœŸè¿›å…¥/é€€å‡ºå¤šé€‰æ¨¡å¼ï¼›æ‰‹æœºç«¯ï¼š**é•¿æŒ‰** ä»»æ„æ—¥æœŸè§¦å‘å¤šé€‰ â†’ ç‚¹å‡»åˆ‡æ¢é€‰ä¸­ï½œ<strong>å³é”®</strong> å•ä¸ªæ—¥æœŸ â†’ åˆ é™¤</p>
        <div id="selectionModeIndicator" class="selection-mode-indicator" style="display: none;">å¤šé€‰æ¨¡å¼ï¼ˆç‚¹å‡»æ—¥æœŸåˆ‡æ¢é€‰ä¸­ï¼‰</div>
        <button class="btn-big" onclick="applyShiftToSelected('big')">è®¾ä¸ºå¤§å¤œç­</button>
        <button class="btn-small" onclick="applyShiftToSelected('small')">è®¾ä¸ºå°å¤œç­</button>
        <button class="btn-delete" onclick="deleteSelected()">åˆ é™¤æ‰€é€‰</button>
        <button class="btn-extra" onclick="openExtraModal()">é¢å¤–è°ƒæ•´</button>
        <button class="btn-clear" onclick="clearSelected()">å–æ¶ˆå¤šé€‰</button>
        <button class="btn-settings" onclick="runCalendarAiAnalysis()">ğŸ§  åˆ†æå¹¶æä¾›æ¢ç­å»ºè®® (å¯åŠ¨å¯¹è¯)</button> 
      </div>

      <div class="calendar" id="calendar"></div>
      <div class="shift-info" id="shiftInfo">
          </div>
      
      <div id="calendarAiChatContainer" style="margin-top: 15px;">
        <h3 id="calendarAiTitle">ğŸ”„ æ’ç­åˆè§„æ€§åˆ†æä¸è®¨è®º</h3>
        <div id="complianceAdviceStatus" style="padding: 10px; border: 1px solid #ddd;
border-radius: 4px;">ç‚¹å‡»ä¸Šæ–¹ "åˆ†æå¹¶æä¾›æ¢ç­å»ºè®®" æŒ‰é’®å¯åŠ¨å¯¹è¯ã€‚</div>
        <div id="calendarChatHistory" class="ai-chat-history"></div>
        <div id="calendarChatInputContainer" class="ai-chat-input-container" style="display:none;">
            <textarea id="calendarChatInput" placeholder="åŸºäºä»¥ä¸Šåˆ†æç»§ç»­æé—®ï¼ˆä¾‹å¦‚ï¼šå°†10å·çš„ç­æŒªåˆ°12å·æ˜¯å¦åˆè§„ï¼Ÿï¼‰" rows="1" onkeydown="handlePanelChatInput(event, 'calendar')"></textarea>
            <button onclick="sendPanelChatMessage('calendar')">å‘é€</button>
        </div>
      </div>

      <div class="week-summary">
        <h3>ğŸ“… è¿ç»­7å¤©å·¥æ—¶ç»Ÿè®¡ï¼ˆä»…å«å½“æœˆæ—¥æœŸçš„è½®æ¬¡ï¼‰</h3>
        <div class="week-list" id="weekList"></div>
      </div>
    </div>

    <div id="panel-stats" class="panel">
      <h2>ğŸ“Š é«˜çº§ç»Ÿè®¡åˆ†æ</h2>
      <div class="stats-controls">
        <div><label>å¼€å§‹æ—¥æœŸ</label><input type="date" id="statStartDate" /></div>
        <div><div><label>ç»“æŸæ—¥æœŸ</label><input type="date" id="statEndDate" /></div></div>
        <div><button class="btn-settings" onclick="renderStatsWithRange()">ğŸ” åˆ†æ</button></div>
      </div>
      <div class="stats-grid" id="statsGrid"></div>
      <div id="chartContainer"><canvas id="monthlyChart"></canvas></div>

      <div style="margin-top: 25px;
border-top: 1px solid #eee; padding-top: 15px;">
          <div id="statsAiChatContainer">
            <h3 id="statsAiTitle">ğŸ“ˆ AI æ™ºèƒ½æ€»ç»“ä¸è®¨è®º</h3>
            <button class="btn-settings" onclick="runAiAnalysis()">ğŸ§  å¯åŠ¨ AI æ€»ç»“ (å¯åŠ¨å¯¹è¯)</button>
            <div id="aiSummaryResultStatus" style="padding: 10px;
border: 1px solid #ddd; border-radius: 4px; margin-top: 10px;">è¯·å…ˆé€‰æ‹©æ—¥æœŸèŒƒå›´å¹¶ç‚¹å‡»â€œåˆ†æâ€ï¼Œç„¶åç‚¹å‡»ä¸Šæ–¹æŒ‰é’®å¯åŠ¨å¯¹è¯ã€‚</div>
            <div id="statsChatHistory" class="ai-chat-history"></div>
            <div id="statsChatInputContainer" class="ai-chat-input-container" style="display:none;">
                <textarea id="statsChatInput" placeholder="åŸºäºä»¥ä¸Šæ€»ç»“ç»§ç»­æé—®ï¼ˆä¾‹å¦‚ï¼šæˆ‘åº”è¯¥å¦‚ä½•åœ¨ä¼‘æ¯æ—¥æ›´å¥½åœ°æ¢å¤ç²¾åŠ›ï¼Ÿï¼‰" rows="1" onkeydown="handlePanelChatInput(event, 'stats')"></textarea>
                <button onclick="sendPanelChatMessage('stats')">å‘é€</button>
            </div>
          </div>
    
   </div>
    </div>

    <div id="panel-chat" class="panel">
        <h2>ğŸ’¬ AI ç§äººå¥åº·åŠ©æ‰‹</h2>
        <p style="color: #666;">
            æ‚¨å¯ä»¥åœ¨æ­¤ä¸ AI ç§äººå¥åº·åŠ©æ‰‹è¿›è¡Œå¯¹è¯ï¼Œè·å–å…³äºå¤œç­ä¸‹çš„å¥åº·ã€æƒ…ç»ªå’Œç”Ÿæ´»è´¨é‡çš„å»ºè®®ã€‚
            <span id="chatConfigStatus" style="font-weight: bold;"></span>
        </p>
        
        <div class="chat-controls">
            <div><label>åˆ†æå¼€å§‹æ—¥æœŸ</label><input type="date" 
id="chatStartDate" /></div>
            <div><div><label>åˆ†æç»“æŸæ—¥æœŸ</label><input type="date" id="chatEndDate" /></div></div>
            <div>
                <button class="btn-settings" onclick="AIAssistant.analyzeShiftData()">ğŸ“ˆ è·å–å¹¶åˆ†ææ’ç­å¯¹å¥åº·çš„å½±å“</button>
            </div>
        </div>
        <div style="margin-top: 10px;">
            <button class="btn-clear" onclick="resetChatHistory()">ğŸ”„ é‡ç½®å¯¹è¯</button>
        
</div>

        <div id="chatContainer">
            <div id="chatHistory"></div>
            <div id="chatInputContainer">
                <textarea id="chatInput" placeholder="è¾“å…¥æ‚¨çš„é—®é¢˜..." rows="1" onkeydown="handleChatInput(event)"></textarea>
                <button id="chatSendBtn" onclick="sendChatMessage()">å‘é€</button>
            </div>
        </div>
    </div>

   
 <div id="panel-settings" class="panel">
      <h2>âš™ï¸ ç³»ç»Ÿè®¾ç½®</h2>
      <p>ä¿®æ”¹åè‡ªåŠ¨ä¿å­˜ï¼Œæ‰€æœ‰è®¾å¤‡åŒæ­¥ç”Ÿæ•ˆã€‚</p>
      <div class="settings-grid">
        <div class="setting-item"><label>å¤§å¤œç­ä¸»æ—¶æ®µï¼ˆå°æ—¶ï¼‰</label><input type="number" step="0.1" id="settingBigMain" /></div>
        <div class="setting-item"><label>å¤§å¤œç­æ¬¡æ—¥æ—¶æ®µï¼ˆå°æ—¶ï¼‰</label><input type="number" step="0.1" id="settingBigNext" /></div>
        <div class="setting-item"><label>å°å¤œç­å·¥æ—¶ï¼ˆå°æ—¶ï¼‰</label><input type="number" step="0.1" id="settingSmall" /></div>
        <div class="setting-item"><label>åˆè§„é˜ˆå€¼ï¼ˆ7å¤©æœ€å¤§å·¥æ—¶ï¼‰</label><input type="number" step="0.1" id="settingLimit" /></div>
        <div class="setting-item"><label>é»˜è®¤è§†å›¾</label><select id="settingDefaultView"><option value="week">æ ‡å‡†å‘¨å†</option><option value="cycle">6å¤©å¾ªç¯å†</option></select></div>
        <div class="setting-item"><label>åŒæ­¥ç”¨æˆ·IDï¼ˆå¤šè®¾å¤‡è¯·ä¿æŒä¸€è‡´ï¼‰</label><input type="text" id="settingUserId" placeholder="è¾“å…¥å­—æ¯æ•°å­—ç»„åˆ" 
/><small style="color:#666;">ç”¨äºåŒºåˆ†ä¸åŒç”¨æˆ·æ•°æ®</small></div>
        
        <div class="setting-item"><label>AI æœåŠ¡ç»ˆç«¯ç‚¹ (Endpoint URL)</label><input type="text" id="settingAiEndpoint" placeholder="å¦‚: https://api.openai.com/v1/chat/completions" /></div>
        <div class="setting-item"><label>AI API å¯†é’¥ (Key)</label><input type="password" id="settingAiApiKey" placeholder="è¾“å…¥æ‚¨çš„å¯†é’¥" /><small style="color:#666;">å¯†é’¥ä»…ä¿å­˜åœ¨æœ¬åœ°/äº‘ç«¯ï¼Œè¯·å¦¥å–„ä¿ç®¡ã€‚</small></div>
        <div class="setting-item"><label>AI æ¨¡å‹åç§°</label><input type="text" id="settingAiModel" placeholder="å¦‚: gpt-3.5-turbo" /><small style="color:#666;">ç”¨äºå¯¹è¯çš„æ¨¡å‹åç§°</small></div>
      </div>
      <div style="text-align:center;
margin-top:20px;">
        <button class="btn-settings" onclick="saveSettings()">ğŸ’¾ ä¿å­˜è®¾ç½®</button>
        <button class="btn-clear" onclick="resetSettings()" style="margin-left:10px;">ğŸ”„ æ¢å¤é»˜è®¤</button>
      </div>
    </div>
  </div>

  <div id="extraModal" class="modal"><div class="modal-content"><h3>é¢å¤–è°ƒæ•´å·¥æ—¶</h3><p>å¯¹æ‰€é€‰æ—¥æœŸï¼Œåœ¨åŸæœ‰åŸºç¡€ä¸Šå¢åŠ æˆ–å‡å°‘å·¥æ—¶</p><div class="unit-selector"><label><input type="radio" name="unit" value="hour" checked /> å°æ—¶ï¼ˆå¦‚ 1.5ï¼‰</label><label><input type="radio" name="unit" value="minute" /> åˆ†é’Ÿï¼ˆå¦‚ -30ï¼‰</label></div><input type="number" id="extraInput" placeholder="è¾“å…¥æ•°å€¼ï¼ˆå¯ä¸ºè´Ÿæ•°ï¼‰" step="any" /><div class="modal-buttons"><button onclick="applyExtra()">ç¡®å®š</button><button onclick="closeExtraModal()">å–æ¶ˆ</button></div></div></div>
  <div id="contextMenu" style="position:absolute;background:white;border:1px solid #ccc;border-radius:4px;box-shadow:2px 2px 6px rgba(0,0,0,0.2);z-index:2000;display:none;min-width:120px;"><div onclick="deleteSingleShift()" style="padding:8px 12px;cursor:pointer;">åˆ é™¤ç­æ¬¡</div></div>

  <script>
    // ============ Supabase é…ç½® ============
    const SUPABASE_URL = 'https://morkovixfwdsaknmwavj.supabase.co';
const SUPABASE_ANON_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6Im1vcmtvdml4Zndkc2Frbm13YXZqIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NjM3MzM1NDIsImV4cCI6MjA3OTMwOTU0Mn0.wh-UEaQyr3bpJBQkCrzJpRR5v4NvRpx3LsnsAo-DGqE';

    // ============ æ ¸å¿ƒæ”¹è¿›ï¼šåŒæ­¥ç®¡ç†å™¨ ============
    class SyncManager {
      constructor() {
        this.isSyncing = false;
this.lastSyncTime = 0;
        this.minSyncInterval = 5000;
        this.pendingSync = false;
      }
      async sync(saveToStorageFn, options = { sync: true }) {
        if (this.isSyncing) {
          this.pendingSync = true;
return;
        }
        const now = Date.now();
if (now - this.lastSyncTime < this.minSyncInterval) {
          if (!this.pendingSync) {
            this.pendingSync = true;
setTimeout(() => {
              this.pendingSync = false;
              this.sync(saveToStorageFn, options);
            }, this.minSyncInterval - (now - self.lastSyncTime));
}
          return;
}
        this.isSyncing = true;
        this.lastSyncTime = now;
try {
          await saveToStorageFn(options);
} finally {
          this.isSyncing = false;
if (this.pendingSync) {
            this.pendingSync = false;
setTimeout(() => this.sync(saveToStorageFn, options), 100);
          }
        }
      }
    }

    const syncManager = new SyncManager();
// ============ æ•°æ®å­˜å‚¨ ============
    function getUserId() {
      let userId = localStorage.getItem('userId');
if (!userId) {
        userId = 'user_' + Math.random().toString(36).substr(2, 9);
        localStorage.setItem('userId', userId);
}
      return userId;
    }

    let supabase;
try {
      supabase = window.supabase.createClient(SUPABASE_URL, SUPABASE_ANON_KEY);
} catch (e) {
      console.error('Supabase åˆå§‹åŒ–å¤±è´¥:', e);
    }

    let shifts = {};
let settings = {};
    let selectedMonth = '';
    let currentView = 'week';
    let multiSelectedDates = new Set();
let rightClickedDate = '';
    let weekSummaries = [];
    let chartInstance = null;
    let isMultiSelectMode = false;
    let currentStatsSummary = {};
document.getElementById('userIdDisplay').textContent = getUserId().substring(0, 8);
    
    // æ ¸å¿ƒä¿å­˜å‡½æ•° (å·²ä¿®æ”¹ä¸ºï¼šèŒƒå›´åˆ é™¤ + æ‰¹é‡æ’å…¥ç­–ç•¥ï¼Œå¹¶ä¼˜åŒ–é”™è¯¯å¤„ç†)
    async function saveToStorage(options = { sync: true }) {
      const userId = getUserId();
      localStorage.setItem('shifts_local', JSON.stringify(shifts));
      localStorage.setItem('selectedMonth_local', selectedMonth);
      localStorage.setItem('shifts_settings_local', JSON.stringify(settings));
      localStorage.setItem('userId', userId);
      
      if (supabase && options.sync) {
        updateSyncStatus('syncing', 'â³ åŒæ­¥ä¸­...');
        try {
          // --- æ ¸å¿ƒä¿®å¤ï¼šé‡‡ç”¨â€œèŒƒå›´åˆ é™¤ + æ‰¹é‡æ’å…¥â€çš„åŒæ­¥ç­–ç•¥ ---
          
          // 1. ç¡®å®šå½“å‰æœˆä»½çš„èŒƒå›´
          const [year, month] = selectedMonth.split('-').map(Number);
          const startOfMonth = `${selectedMonth}-01`;
          const endOfMonth = new Date(year, month, 0).toISOString().split('T')[0]; 

          // 2. ç­›é€‰å‡ºå½“å‰æœˆä»½éœ€è¦ä¸Šä¼ çš„ shifts
          const shiftsToInsert = Object.entries(shifts)
              .filter(([date, data]) => 
                  date >= startOfMonth && 
                  date <= endOfMonth && 
                  data?.type !== 'none' && 
                  data?.hours !== undefined
              )
              .map(([date, data]) => ({
                  user_id: userId, 
                  date: date, 
                  data: data, 
                  updated_at: new Date().toISOString() 
              }));

          // 3. Upsert Settings (ç¡®ä¿å•è¡Œè®°å½•)
          const settingsPromise = supabase.from('settings').upsert({ 
              user_id: userId, 
              data: settings, 
              updated_at: new Date().toISOString() 
          }).select(); 

          // 4. **å¼ºåˆ¶åˆ é™¤** è¯¥æœˆä»½å½“å‰ç”¨æˆ·çš„æ‰€æœ‰è®°å½• (Delete by Range)
          const deletePromise = supabase.from('shifts')
              .delete()
              .eq('user_id', userId)
              .gte('date', startOfMonth) 
              .lte('date', endOfMonth);

          // 5. æ‰¹é‡æ’å…¥æ–°è®°å½• (Insert)
          let insertPromise;
          if (shiftsToInsert.length > 0) {
              // å…³é”®ï¼šè¿™é‡Œä¸èƒ½ä½¿ç”¨ upsertï¼Œå› ä¸º upsert ä»ç„¶å¯èƒ½å› ä¹‹å‰çš„è„æ•°æ®è§¦å‘å†²çªã€‚
              // å¿…é¡»å…ˆè¿›è¡Œåˆ é™¤ï¼Œå†å°è¯•æ’å…¥ã€‚
              insertPromise = supabase.from('shifts').insert(shiftsToInsert).select(); 
          } else {
              insertPromise = Promise.resolve({ data: [], error: null });
          }

          // 6. ç»Ÿä¸€ç­‰å¾…å¹¶æ£€æŸ¥æ‰€æœ‰æ“ä½œ
          const [deleteResponse, insertResponse, settingsResponse] = await Promise.all([deletePromise, insertPromise, settingsPromise]);

          if (deleteResponse.error) {
              // åˆ é™¤æ“ä½œå¤±è´¥å¯èƒ½å¯¼è‡´åç»­æ’å…¥å¤±è´¥ï¼Œä½†æˆ‘ä»¬å°è¯•ç»§ç»­
              console.warn('äº‘ç«¯åˆ é™¤æ“ä½œé‡åˆ°è­¦å‘Šï¼ˆä½†å°è¯•ç»§ç»­ï¼‰:', deleteResponse.error);
          }

          if (insertResponse.error) {
              throw insertResponse.error; // æ’å…¥å¤±è´¥å¿…é¡»æŠ¥é”™
          }
          if (settingsResponse.error) {
              throw settingsResponse.error;
          }

          updateSyncStatus('synced', 'âœ“ å·²åŒæ­¥');
        } catch (error) {
          console.error('äº‘ç«¯åŒæ­¥å¤±è´¥:', error);
          // å§‹ç»ˆæ˜¾ç¤ºè¯¦ç»†é”™è¯¯ä¿¡æ¯
          const errorMessage = error.message || String(error);
          updateSyncStatus('error', 'âœ— åŒæ­¥å¤±è´¥: ' + errorMessage.substring(0, 50) + '...');
        }
      }
    }

    function saveToStorageSafe(options = { sync: true }) {
      return syncManager.sync(saveToStorage, options);
    }

    async function loadFromCloud() {
      if (!supabase) { loadFromLocal(); return;
}
      const userId = getUserId();
      updateSyncStatus('syncing', 'â³ åŠ è½½äº‘ç«¯æ•°æ®...');
try {
        // ç¡®ä¿ load èƒ½å¤Ÿè·å–æ‰€æœ‰æ•°æ®ï¼Œä¸ä»…æ˜¯å½“å‰æœˆ
        const { data: shiftsData, error: shiftsError } = await supabase.from('shifts').select('date, data').eq('user_id', userId);
if (shiftsError) throw shiftsError;
        const { data: settingsData, error: settingsError } = await supabase.from('settings').select('data').eq('user_id', userId).single();
if (settingsError && settingsError.code !== 'PGRST116') throw settingsError;
        
        if (shiftsData) {
          // åˆ›å»ºæ–°çš„ shifts å¯¹è±¡ï¼Œè¦†ç›–æœ¬åœ°æ•°æ®
          shifts = {};
          shiftsData.forEach(row => { shifts[row.date] = row.data; });
          localStorage.setItem('shifts_local', JSON.stringify(shifts));
        }
        
        if (settingsData?.data) {
          settings = { ...defaultSettings, ...settingsData.data };
          localStorage.setItem('shifts_settings_local', JSON.stringify(settings));
        }
        
        updateSyncStatus('synced', 'âœ“ å·²åŠ è½½');
} catch (error) {
        console.error('äº‘ç«¯åŠ è½½å¤±è´¥:', error);
        updateSyncStatus('error', 'âœ— åŠ è½½å¤±è´¥');
        loadFromLocal();
}
    }

    function loadFromLocal() {
      shifts = JSON.parse(localStorage.getItem('shifts_local') || '{}');
selectedMonth = localStorage.getItem('selectedMonth_local') || new Date().toISOString().slice(0, 7);
      settings = { ...defaultSettings, ...JSON.parse(localStorage.getItem('shifts_settings_local') || '{}') };
}

    function updateSyncStatus(type, message) {
      const statusEl = document.getElementById('syncStatus');
statusEl.className = 'sync-status ' + type;
      statusEl.textContent = message;
    }
    
    // æ–°å¢åŒæ­¥æŒ‰é’®é€»è¾‘
    async function forceLoad() {
      await loadFromCloud();
      renderCalendar();
      if (document.getElementById('panel-stats').classList.contains('active')) {
          initDateRangeForStats(true); 
      }
    }

    async function forceUpload() {
        if (syncManager.isSyncing) {
            updateSyncStatus('warning', 'âš ï¸ æ­£åœ¨åŒæ­¥ä¸­ï¼Œè¯·ç¨å€™...');
            return;
        }
        updateSyncStatus('syncing', 'â³ æ­£åœ¨ä¸Šä¼ ...');
        // è°ƒç”¨ä¿å­˜å‡½æ•°ï¼Œå¼ºåˆ¶è¿›è¡Œäº‘ç«¯åŒæ­¥
        await saveToStorageSafe({ sync: true }); 
    }

    const defaultSettings = {
      bigMain: 7.4, bigNext: 3, small: 9.3, limit: 40, defaultView: 'week',
      aiEndpoint: 'https://api.openai.com/v1/chat/completions', aiApiKey: '', aiModel: 'gpt-3.5-turbo'
};
    function switchTab(tab) {
      ['calendar', 'stats', 'chat', 'settings'].forEach(t => {
        document.getElementById(`panel-${t}`).classList.remove('active');
        document.getElementById(`tab-${t}`).classList.remove('active');
      });
document.getElementById(`panel-${tab}`).classList.add('active');
      document.getElementById(`tab-${tab}`).classList.add('active');
      if (tab === 'stats') { initDateRangeForStats(true); } 
      else if (tab === 'chat') { initDateRangeForChat();
AIAssistant.initSystemMessage(); document.getElementById('chatInput').focus(); } 
      else if (tab === 'settings') { loadSettingsUI();
}
      AIAssistant.updateChatConfigStatus(); // Update status on tab switch
    }

    function switchView(view) {
      currentView = view;
settings.defaultView = view;
      saveToStorageSafe({ sync: true });
      document.querySelectorAll('.view-toggle button').forEach(btn => btn.classList.remove('active'));
      if (view === 'week') { document.getElementById('btn-week').classList.add('active');
} 
      else { document.getElementById('btn-cycle').classList.add('active'); }
      renderCalendar();
}

    function loadSettingsUI() {
      document.getElementById('settingBigMain').value = settings.bigMain;
      document.getElementById('settingBigNext').value = settings.bigNext;
document.getElementById('settingSmall').value = settings.small;
      document.getElementById('settingLimit').value = settings.limit;
      document.getElementById('settingDefaultView').value = settings.defaultView;
      document.getElementById('settingUserId').value = getUserId();
      document.getElementById('settingAiEndpoint').value = settings.aiEndpoint || '';
document.getElementById('settingAiApiKey').value = settings.aiApiKey || '';
      document.getElementById('settingAiModel').value = settings.aiModel || '';
}

    async function saveSettings() {
      const s = settings;
s.bigMain = parseFloat(document.getElementById('settingBigMain').value) || defaultSettings.bigMain;
      s.bigNext = parseFloat(document.getElementById('settingBigNext').value) || defaultSettings.bigNext;
      s.small = parseFloat(document.getElementById('settingSmall').value) || defaultSettings.small;
      s.limit = parseFloat(document.getElementById('settingLimit').value) || defaultSettings.limit;
s.defaultView = document.getElementById('settingDefaultView').value;
      s.aiEndpoint = document.getElementById('settingAiEndpoint').value.trim();
      s.aiApiKey = document.getElementById('settingAiApiKey').value.trim();
      s.aiModel = document.getElementById('settingAiModel').value.trim();
      
      const newUserId = document.getElementById('settingUserId').value.trim();
if (newUserId && newUserId !== getUserId()) {
        localStorage.setItem('userId', newUserId);
        alert('ğŸ†” ç”¨æˆ·IDå·²æ›´æ–°ï¼è¯·åœ¨å…¶ä»–è®¾å¤‡å¡«å…¥ç›¸åŒIDä»¥å®ç°åŒæ­¥');
}
      await saveToStorageSafe({ sync: true });
      alert('âœ… è®¾ç½®å·²ä¿å­˜å¹¶åŒæ­¥åˆ°äº‘ç«¯ï¼');
      AIAssistant.initSystemMessage();
      AIAssistant.updateChatConfigStatus();
if (currentView !== s.defaultView) { switchView(s.defaultView); }
      renderCalendar();
}

    function resetSettings() {
      if (confirm('ç¡®å®šæ¢å¤é»˜è®¤è®¾ç½®ï¼Ÿ')) {
        settings = { ...defaultSettings };
saveToStorageSafe({ sync: true });
        loadSettingsUI();
        AIAssistant.initSystemMessage();
        AIAssistant.updateChatConfigStatus();
        renderCalendar();
        alert('å·²æ¢å¤é»˜è®¤è®¾ç½®');
      }
    }

    // ============ æ—¥å†é€»è¾‘ ============

    const dayNames = ['æ—¥', 'ä¸€', 'äºŒ', 'ä¸‰', 'å››', 'äº”', 'å…­'];
    
    function getDayLabel(date, view) {
      if (view === 'cycle') {
        const firstDayOfMonth = new Date(date.getFullYear(), date.getMonth(), 1);
        const dayDiff = Math.floor((date - firstDayOfMonth) / (1000 * 60 * 60 * 24));
        const cycleIndex = (dayDiff % 6) + 1;
        return `æ—¥${cycleIndex}`;
      }
      return dayNames[date.getDay()];
    }

    function getShiftDisplay(shiftData) {
      if (!shiftData || shiftData.type === 'none') return '';
      if (shiftData.type === 'auto-next') return `<span style="color:#1890ff;">${shiftData.hours.toFixed(1)}h (æ¬¡æ—¥)</span>`;
      const baseHours = shiftData.hours;
      const extra = shiftData.extra || 0;
      const total = baseHours + extra;
      let typeLabel = '';
      if (shiftData.type === 'big') typeLabel = 'å¤§å¤œ';
      else if (shiftData.type === 'small') typeLabel = 'å°å¤œ';
      else if (shiftData.type === 'custom') typeLabel = 'è‡ªå®šä¹‰';

      let html = `<span style="font-weight:bold;">${typeLabel}</span>`;
      html += `<div class="day-total">${total.toFixed(1)}h</div>`;
      if (extra !== 0) {
        html += `<div class="day-extra">(${extra > 0 ? '+' : ''}${extra.toFixed(1)}h)</div>`;
      }
      return html;
    }

    function getDailyHours(dateStr) {
      const shift = shifts[dateStr];
      if (!shift || shift.type === 'none') return 0;
      return (shift.hours || 0) + (shift.extra || 0);
    }

    function getShiftType(shiftData) {
        if (!shiftData) return 'none';
        return shiftData.type;
    }

    function getDetailedShifts(startDateStr, endDateStr) {
        const detailedShifts = [];
        const startDate = new Date(startDateStr);
        const endDate = new Date(endDateStr);
        let currentDate = new Date(startDate);
        
        while (currentDate <= endDate) {
            const dateStr = currentDate.toISOString().split('T')[0];
            const shiftData = shifts[dateStr];
            let baseHours = 0;
            let extraHours = 0;
            let totalHours = 0;

            if (shiftData && shiftData.type !== 'none') {
                baseHours = shiftData.hours || 0;
                extraHours = shiftData.extra || 0;
                totalHours = baseHours + extraHours;
            }

            if (shiftData && shiftData.type !== 'none' && shiftData.type !== 'auto-next') {
                detailedShifts.push({
                    date: dateStr,
                    shiftType: shiftData.type,
                    baseHours: parseFloat(baseHours.toFixed(2)),
                    extraHours: parseFloat(extraHours.toFixed(2)),
                    totalHours: parseFloat(totalHours.toFixed(2)),
                    raw: shiftData
                });
            }
            currentDate.setDate(currentDate.getDate() + 1);
        }
        return detailedShifts;
    }

    function exportData() {
      const data = {
        version: 'cloud-sync-v4',
        exportTime: new Date().toLocaleString(),
        userId: getUserId(),
        month: selectedMonth,
        shifts: shifts,
        settings: settings
      };
      const json = JSON.stringify(data, null, 2);
      const blob = new Blob([json], { type: 'application/json' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = `shift_data_backup_${new Date().toISOString().slice(0,10)}.json`;
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
    }

    function importData(event) {
      const file = event.target.files[0];
      if (!file) return;
      const reader = new FileReader();
      reader.onload = async function(e) {
        try {
          const data = JSON.parse(e.target.result);
          if (data.version !== 'cloud-sync-v4' || !data.shifts || !data.settings) throw new Error('æ–‡ä»¶æ ¼å¼ä¸åŒ¹é…');
          if (!confirm(`ç¡®å®šå¯¼å…¥å¤‡ä»½æ–‡ä»¶ï¼ˆ${data.exportTime}ï¼‰ï¼Ÿè¿™å°†è¦†ç›–ç°æœ‰æ•°æ®ã€‚`)) return;
          shifts = data.shifts;
          selectedMonth = data.month;
          settings = { ...defaultSettings, ...data.settings };
          localStorage.setItem('userId', data.userId);
          await saveToStorageSafe({ sync: true });
          document.getElementById('monthInput').value = selectedMonth;
          loadSettingsUI();
          renderCalendar();
          alert('âœ… æ•°æ®å¯¼å…¥å¹¶åŒæ­¥æˆåŠŸï¼');
        } catch (err) {
          console.error(err);
          alert('å¯¼å…¥å¤±è´¥ï¼šæ–‡ä»¶æ ¼å¼é”™è¯¯');
        }
      };
      reader.readAsText(file);
      event.target.value = '';
    }

    function renderCalendar() {
      const monthInput = document.getElementById('monthInput').value;
      if (!monthInput) return;
      selectedMonth = monthInput;
      saveToStorageSafe({ sync: true });
      const year = parseInt(selectedMonth.split('-')[0]);
      const month = parseInt(selectedMonth.split('-')[1]) - 1;
      const firstDay = new Date(year, month, 1);
      const lastDay = new Date(year, month + 1, 0);
      const daysInMonth = lastDay.getDate();
      const calendarEl = document.getElementById('calendar');
      calendarEl.innerHTML = '';
      let cols = 7;
      let showHeaders = true;
      if (currentView === 'cycle') {
        cols = 6;
        showHeaders = false;
      }
      if (showHeaders) {
        calendarEl.style.gridTemplateColumns = `repeat(${cols}, 1fr)`;
        const dayHeaders = currentView === 'week' ? dayNames : ['æ—¥', 'ä¸€', 'äºŒ', 'ä¸‰', 'å››', 'äº”', 'å…­'].slice(1, 7);
        dayHeaders.forEach(day => {
          const header = document.createElement('div');
          header.className = 'day-header';
          header.textContent = day;
          calendarEl.appendChild(header);
        });
      } else {
        calendarEl.style.gridTemplateColumns = `repeat(6, 1fr)`; // Cycle view always 6 cols
      }

      const startDay = firstDay.getDay(); // 0-6 (Sun-Sat)

      // Add empty cells for padding
      let firstCellOffset = 0;
      if (currentView === 'week') {
        firstCellOffset = startDay;
      } else { // cycle view (6 days) starts from Monday (1) to Saturday (6), Sunday (0) is last if needed.
        if (startDay === 0) firstCellOffset = 5; // Sunday is the last day of the 6-day cycle if view is week.
        else firstCellOffset = startDay - 1; // 1 (Mon) -> 0 offset, 6 (Sat) -> 5 offset
      }

      for (let i = 0; i < firstCellOffset; i++) {
        const emptyCell = document.createElement('div');
        emptyCell.className = 'day-cell empty';
        calendarEl.appendChild(emptyCell);
      }
      
      let pressTimer;
      for (let i = 1; i <= daysInMonth; i++) {
        const date = new Date(year, month, i);
        const dateStr = date.toISOString().split('T')[0];
        const cell = document.createElement('div');
        cell.className = 'day-cell';
        cell.dataset.date = dateStr;
        cell.innerHTML = `<div class="day-number">${i}</div>`;
        const shiftData = shifts[dateStr];
        cell.innerHTML += getShiftDisplay(shiftData);

        cell.addEventListener('click', (e) => {
            const dateStr = cell.dataset.date;

            if (e.ctrlKey || e.metaKey) {
                e.preventDefault();
                if (!isMultiSelectMode) { 
                    isMultiSelectMode = true;
                    updateMultiSelectUI();
                }
                toggleMultiSelect(dateStr, cell);
                return;
            }

            if (isMultiSelectMode) {
                toggleMultiSelect(dateStr, cell);
                return;
            }

            if (e.detail === 1) { 
                if (multiSelectedDates.size > 1 || !multiSelectedDates.has(dateStr)) {
                    clearSelected(); 
                    multiSelectedDates.add(dateStr); 
                    cell.classList.add('multi-selected'); 
                } else {
                    clearSelected();
                }
                updateShiftInfo(true); // Force update shift info
            }
        });

        cell.addEventListener('mousedown', (e) => {
          const dateStr = cell.dataset.date;
          if (e.button === 0 && !(e.ctrlKey || e.metaKey)) { 
            pressTimer = setTimeout(() => { 
                isMultiSelectMode = true; 
                updateMultiSelectUI(); 
                toggleMultiSelect(dateStr, cell); 
            }, 500); 
          }
        });

        cell.addEventListener('mouseup', () => clearTimeout(pressTimer));
        cell.addEventListener('mouseleave', () => clearTimeout(pressTimer));
        
        cell.addEventListener('contextmenu', (e) => { 
            e.preventDefault(); 
            rightClickedDate = dateStr; 
            const menu = document.getElementById('contextMenu'); 
            menu.style.display = 'block'; 
            menu.style.left = e.pageX + 'px'; 
            menu.style.top = e.pageY + 'px'; 
        });

        updateCellClass(cell, dateStr);
        calendarEl.appendChild(cell);
      }

      document.addEventListener('click', () => {
        document.getElementById('contextMenu').style.display = 'none';
      });

      checkCompliance();
      updateShiftInfo(false); // Initial render, do not force clear (only clear on button actions)
      updateWeekSummary();
    }

    function toggleMultiSelect(dateStr, cell) {
      if (multiSelectedDates.has(dateStr)) {
        multiSelectedDates.delete(dateStr);
        cell.classList.remove('multi-selected');
      } else {
        multiSelectedDates.add(dateStr);
        cell.classList.add('multi-selected');
      }
      updateMultiSelectUI();
    }

    function clearMultiSelectUI() {
      document.querySelectorAll('.day-cell.multi-selected').forEach(el => {
        el.classList.remove('multi-selected');
      });
    }

    function updateCellClass(cell, dateStr) {
      cell.classList.remove('selected-big', 'selected-small', 'custom', 'over-limit', 'multi-selected');
      if (multiSelectedDates.has(dateStr)) {
          cell.classList.add('multi-selected');
      }

      const shift = shifts[dateStr];
      if (shift) {
        if (shift.type === 'big') cell.classList.add('selected-big');
        else if (shift.type === 'small') cell.classList.add('selected-small');
        else if (shift.type === 'custom') cell.classList.add('custom');
      }
    }

    function updateMultiSelectUI() {
      const indicator = document.getElementById('selectionModeIndicator');
      const hint = document.getElementById('multiSelectHint');
      if (isMultiSelectMode || multiSelectedDates.size > 0) {
        indicator.style.display = 'inline-block';
        hint.style.display = 'none';
        indicator.textContent = isMultiSelectMode ? 'å¤šé€‰æ¨¡å¼ï¼ˆç‚¹å‡»æ—¥æœŸåˆ‡æ¢é€‰ä¸­ï¼‰' : `å·²é€‰æ‹© ${multiSelectedDates.size} ä¸ªæ—¥æœŸ`;
      } else {
        indicator.style.display = 'none';
        hint.style.display = 'block';
      }
      
      document.querySelectorAll('.day-cell').forEach(cell => {
          updateCellClass(cell, cell.dataset.date);
      });
      updateShiftInfo(false); 
    }
    
    async function applyShiftToSelected(type) {
      if (multiSelectedDates.size === 0) {
        alert('è¯·å…ˆé€‰æ‹©è‡³å°‘ä¸€ä¸ªæ—¥æœŸ');
        return;
      }
      multiSelectedDates.forEach(dateStr => {
        const shift = shifts[dateStr] || { type: 'none', hours: 0, extra: 0 };
        
        // åˆ é™¤æ—§ç­æ¬¡çš„æ¬¡æ—¥è®°å½•ï¼ˆå¦‚æœæœ‰ï¼‰
        if (shift.type === 'big') {
            const nextDay = new Date(dateStr);
            nextDay.setDate(nextDay.getDate() + 1);
            const nextDayStr = nextDay.toISOString().split('T')[0];
            if (shifts[nextDayStr]?.type === 'auto-next') delete shifts[nextDayStr];
        }

        if (type === 'big') {
          shifts[dateStr] = { type: 'big', hours: settings.bigMain, extra: shift.extra || 0 };
          const nextDay = new Date(dateStr);
          nextDay.setDate(nextDay.getDate() + 1);
          const nextDayStr = nextDay.toISOString().split('T')[0];
          shifts[nextDayStr] = { type: 'auto-next', hours: settings.bigNext, extra: 0 };
        } else if (type === 'small') {
          shifts[dateStr] = { type: 'small', hours: settings.small, extra: shift.extra || 0 };
        }
      });
      await saveToStorageSafe({ sync: true });
      renderCalendar();
      clearSelected(); 
    }

    // ä¿®å¤ï¼šåˆ é™¤æ‰€é€‰ç­æ¬¡æ—¶ï¼Œåªå¤„ç†æœ¬åœ°æ•°æ®ï¼Œç„¶ååŒæ­¥
    async function deleteSelected() {
      if (multiSelectedDates.size === 0) {
        alert('è¯·å…ˆé€‰æ‹©è‡³å°‘ä¸€ä¸ªæ—¥æœŸ');
        return;
      }
      if (!confirm(`ç¡®å®šåˆ é™¤è¿™ ${multiSelectedDates.size} ä¸ªæ—¥æœŸçš„æ’ç­è®°å½•å—ï¼Ÿ`)) return;

      const datesToDelete = Array.from(multiSelectedDates);

      datesToDelete.forEach(dateStr => {
        // 1. åˆ é™¤æ¬¡æ—¥ç­æ¬¡ (æœ¬åœ°)
        if (shifts[dateStr]?.type === 'big') {
            const nextDay = new Date(dateStr);
            nextDay.setDate(nextDay.getDate() + 1);
            const nextDayStr = nextDay.toISOString().split('T')[0];
            if (shifts[nextDayStr]?.type === 'auto-next') {
              delete shifts[nextDayStr];
            }
        }
        // 2. åˆ é™¤ä¸»ç­æ¬¡æœ¬åœ°è®°å½•
        delete shifts[dateStr];
      });
      
      // 3. è§¦å‘åŒæ­¥ã€‚æ–°é€»è¾‘ä¼šè‡ªåŠ¨åˆ é™¤äº‘ç«¯ä¸­å½“å‰æœˆä»½å†…è¢«åˆ é™¤çš„è®°å½•ã€‚
      await saveToStorageSafe({ sync: true });
      
      renderCalendar();
      clearSelected(); 
    }

    // ä¿®å¤ï¼šå³é”®åˆ é™¤å•ä¸ªç­æ¬¡æ—¶ï¼Œåªå¤„ç†æœ¬åœ°æ•°æ®ï¼Œç„¶ååŒæ­¥
    async function deleteSingleShift() {
      document.getElementById('contextMenu').style.display = 'none';
      if (!rightClickedDate) return;
      
      // åˆ é™¤æ¬¡æ—¥ç­æ¬¡ï¼ˆå¦‚æœæ˜¯å¤§å¤œç­ï¼‰
      if (shifts[rightClickedDate]?.type === 'big') {
          const nextDay = new Date(rightClickedDate);
          nextDay.setDate(nextDay.getDate() + 1);
          const nextDayStr = nextDay.toISOString().split('T')[0];
          if (shifts[nextDayStr]?.type === 'auto-next') {
            delete shifts[nextDayStr];
          }
      }
      
      // åˆ é™¤ä¸»ç­æ¬¡æœ¬åœ°è®°å½•
      delete shifts[rightClickedDate];

      // è§¦å‘åŒæ­¥ã€‚æ–°é€»è¾‘ä¼šè‡ªåŠ¨åˆ é™¤äº‘ç«¯ä¸­å½“å‰æœˆä»½å†…è¢«åˆ é™¤çš„è®°å½•ã€‚
      await saveToStorageSafe({ sync: true });
      rightClickedDate = '';
      renderCalendar();
    }

    function clearSelected() {
      clearMultiSelectUI();
      multiSelectedDates.clear();
      isMultiSelectMode = false;
      updateMultiSelectUI();
    }

    function openExtraModal() {
      if (multiSelectedDates.size === 0) {
        alert('è¯·å…ˆé€‰æ‹©è‡³å°‘ä¸€ä¸ªæ—¥æœŸ');
        return;
      }
      document.getElementById('extraInput').value = '';
      document.querySelector('input[name="unit"][value="hour"]').checked = true;
      document.getElementById('extraModal').style.display = 'flex';
    }

    function closeExtraModal() {
      document.getElementById('extraModal').style.display = 'none';
    }

    async function applyExtra() {
      const extraInputEl = document.getElementById('extraInput');
      let value = parseFloat(extraInputEl.value);
      const unit = document.querySelector('input[name="unit"]:checked').value;
      closeExtraModal();
      if (isNaN(value) || value === 0) return;
      if (unit === 'minute') {
        value /= 60; // Convert minutes to hours
      }

      multiSelectedDates.forEach(dateStr => {
        const shift = shifts[dateStr];
        if (shift) {
          shift.type = shift.type === 'big' || shift.type === 'small' ? shift.type : 'custom';
          shift.extra = (shift.extra || 0) + value;
          if (shift.type === 'custom' && !shift.hours) {
              shift.hours = 0; 
          }
        } else {
          shifts[dateStr] = { type: 'custom', hours: 0, extra: value };
        }
      });
      await saveToStorageSafe({ sync: true });
      renderCalendar();
      clearSelected(); 
    }

    function generateAllRelevant7DayWindows() {
      const windows = [];
      const [year, month] = selectedMonth.split('-').map(Number);
      const firstDayOfMonth = new Date(year, month - 1, 1);
      const lastDayOfMonth = new Date(year, month, 0);
      
      const start = new Date(firstDayOfMonth);
      start.setDate(start.getDate() - 6);
      const end = lastDayOfMonth;
      
      let current = new Date(start);
      while (current <= end) {
        const windowEnd = new Date(current);
        windowEnd.setDate(windowEnd.getDate() + 6); // 7th day is windowEnd
        
        if (windowEnd >= firstDayOfMonth) {
            windows.push({ start: new Date(current), end: windowEnd });
        }
        current.setDate(current.getDate() + 1);
      }
      return windows;
    }

    function checkCompliance() {
      const windows = generateAllRelevant7DayWindows();
      weekSummaries = [];
      const overLimitDates = new Set();
      const limit = settings.limit;

      windows.forEach(w => {
        let total = 0;
        const datesInRange = [];
        for (let i = 0; i < 7; i++) {
          const d = new Date(w.start);
          d.setDate(d.getDate() + i);
          const iso = d.toISOString().split('T')[0];
          datesInRange.push(iso);
          total += getDailyHours(iso);
        }
        const violation = total > limit;
        weekSummaries.push({
          start: w.start.toISOString().split('T')[0],
          end: w.end.toISOString().split('T')[0],
          total: total,
          dates: datesInRange,
          violation: violation
        });
        if (violation) {
          // Only mark dates within the current month as over-limit on the UI
          datesInRange.forEach(d => {
              if (d.startsWith(selectedMonth)) overLimitDates.add(d);
          });
        }
      });

      document.querySelectorAll('.day-cell').forEach(cell => {
        const dateStr = cell.dataset.date;
        if (dateStr && overLimitDates.has(dateStr)) cell.classList.add('over-limit');
        else cell.classList.remove('over-limit');
      });
    }

    // è®¡ç®—æœ¬æœˆæ€»å·¥æ—¶
    function calculateMonthlyStats() {
        let totalHours = 0;
        const [year, month] = selectedMonth.split('-').map(Number);
        const lastDayOfMonth = new Date(year, month, 0).getDate(); 

        for (let day = 1; day <= lastDayOfMonth; day++) {
            const dateStr = `${selectedMonth}-${day.toString().padStart(2, '0')}`;
            totalHours += getDailyHours(dateStr); 
        }
        return { totalHours };
    }
    
    // æ›´æ–°æ’ç­ä¿¡æ¯æ˜¾ç¤ºåŒºåŸŸ (æ˜¾ç¤ºæ€»å°æ—¶å’Œåˆè§„åˆ¤æ–­)
    function updateShiftInfo(showDetailed = false) {
      const infoEl = document.getElementById('shiftInfo');
      const { totalHours } = calculateMonthlyStats();

      // åˆè§„æ£€æŸ¥ï¼š
      const violations = weekSummaries.filter(w => w.violation && (w.start.startsWith(selectedMonth) || w.end.startsWith(selectedMonth)));
      const violationCount = violations.length;
      const limit = settings.limit || 40; 
      
      let complianceHtml;
      if (violationCount > 0) {
          complianceHtml = `<p class="result warn">âŒ é£é™©æç¤ºï¼šæ£€æµ‹åˆ° ${violationCount} è½®è¿ç»­7å¤©å·¥æ—¶è¶…è¿‡ ${limit.toFixed(1)} å°æ—¶ï¼</p>`;
      } else {
          complianceHtml = `<p class="result ok">âœ… åˆè§„ï¼šæœ¬æœˆæ’ç­ç¬¦åˆè¿ç»­7å¤©å·¥æ—¶ä¸è¶…è¿‡ ${limit.toFixed(1)} å°æ—¶çš„è§„å®šã€‚</p>`;
      }

      let html = `
          <div style="font-size: 16px; font-weight: bold; color: #1890ff; margin-bottom: 10px; text-align: center;">
              æœ¬æœˆæ€»å·¥æ—¶ï¼š${totalHours.toFixed(1)} å°æ—¶
          </div>
          ${complianceHtml}
      `;

      if (multiSelectedDates.size > 0 && showDetailed) {
          let selectionTotalHours = 0;
          let shiftsCount = { big: 0, small: 0, custom: 0, none: 0 };
          const selectedDatesArray = Array.from(multiSelectedDates).sort();
          const detailedList = [];

          selectedDatesArray.forEach(dateStr => {
              const shift = shifts[dateStr];
              const hours = getDailyHours(dateStr);
              selectionTotalHours += hours;
              const type = getShiftType(shift);
              shiftsCount[type]++;

              let shiftDetails = '';
              if (type !== 'none') {
                  const base = (shift.hours || 0).toFixed(1);
                  const extra = (shift.extra || 0).toFixed(1);
                  shiftDetails = `æ€»å·¥æ—¶: ${hours.toFixed(1)}h (åŸºç¡€: ${base}h, é¢å¤–: ${extra}h)`;
              } else {
                  shiftDetails = 'æ— ç­æ¬¡';
              }
              detailedList.push(`<li>${dateStr} (${type === 'big' ? 'å¤§å¤œ' : type === 'small' ? 'å°å¤œ' : type === 'custom' ? 'è‡ªå®šä¹‰' : 'ä¼‘æ¯'}): ${shiftDetails}</li>`);
          });

          html += `
              <hr style="margin-top: 10px; margin-bottom: 10px;">
              <h3>å·²é€‰æ‹© ${multiSelectedDates.size} ä¸ªæ—¥æœŸ</h3>
              <p><strong>ç´¯è®¡æ€»å·¥æ—¶: ${selectionTotalHours.toFixed(1)} å°æ—¶</strong></p>
              <p style="font-size: 14px;">
                  å¤§å¤œç­: ${shiftsCount.big} æ¬¡, 
                  å°å¤œç­: ${shiftsCount.small} æ¬¡, 
                  è‡ªå®šä¹‰: ${shiftsCount.custom} æ¬¡, 
                  ä¼‘æ¯æ—¥: ${shiftsCount.none} å¤©
              </p>
              <h4 style="margin-top: 10px;">é€‰æ‹©æ—¥æœŸæ˜ç»†:</h4>
              <ul style="max-height: 150px; overflow-y: auto; list-style-type: none; padding-left: 0; font-size: 12px;">
                  ${detailedList.join('')}
              </ul>
          `;
      } else if (multiSelectedDates.size === 0) {
          html += '<p style="margin-top: 10px;">è¯·ç‚¹å‡»ï¼ˆæˆ– Ctrl/Cmd+ç‚¹å‡»ï¼‰æ—¥æœŸä»¥é€‰æ‹©æ’ç­æ—¥æœŸï¼Œç„¶åä½¿ç”¨ä¸Šæ–¹æŒ‰é’®è®¾ç½®ç­æ¬¡ã€‚</p>';
      }

      infoEl.innerHTML = html;
    }

    function updateWeekSummary() {
      const listEl = document.getElementById('weekList');
      listEl.innerHTML = '';
      const limit = settings.limit;
      weekSummaries.filter(w => w.start.startsWith(selectedMonth) || w.end.startsWith(selectedMonth)).forEach(w => {
        const item = document.createElement('div');
        item.className = 'week-item' + (w.violation ? ' violation' : '');
        const range = `${w.start.split('-').slice(1).join('/')} - ${w.end.split('-').slice(1).join('/')}`;
        let violationText = '';
        if (w.violation) {
          const diff = (w.total - limit).toFixed(1);
          violationText = ` (è¶…é™ ${diff}h)`;
        }
        item.innerHTML = `
            <span>${range}</span> 
            <span style="float: right;"><strong>${w.total.toFixed(1)}h</strong>${violationText}</span>
        `;
        listEl.appendChild(item);
      });
    }

    // ============ ç»Ÿè®¡åˆ†æé€»è¾‘ (ä¿æŒä¸å˜) ============

    function getMonthsBetween(startDate, endDate) {
        let months = [];
        let currentDate = new Date(startDate.getFullYear(), startDate.getMonth(), 1);
        const endMonth = endDate.getMonth();
        const endYear = endDate.getFullYear();

        while (currentDate.getFullYear() < endYear || (currentDate.getFullYear() === endYear && currentDate.getMonth() <= endMonth)) {
            months.push(currentDate.toISOString().slice(0, 7));
            currentDate.setMonth(currentDate.getMonth() + 1);
        }
        return months;
    }

    function generateAnalysisData() {
        const startInput = document.getElementById('statStartDate').value;
        const endInput = document.getElementById('statEndDate').value;
        if (!startInput || !endInput) return { error: 'è¯·é€‰æ‹©æœ‰æ•ˆçš„æ—¥æœŸèŒƒå›´' };

        const [sYear, sMonth, sDay] = startInput.split('-').map(Number);
        const [eYear, eMonth, eDay] = endInput.split('-').map(Number);
        const startDate = new Date(sYear, sMonth - 1, sDay);
        const endDate = new Date(eYear, eMonth - 1, eDay);
        endDate.setHours(23, 59, 59, 999);

        if (startDate > endDate) return { error: 'å¼€å§‹æ—¥æœŸä¸èƒ½æ™šäºç»“æŸæ—¥æœŸ' };

        const allMonths = getMonthsBetween(startDate, endDate);
        let totalWorkDays = 0;
        let totalHours = 0;
        let bigCount = 0, smallCount = 0, customCount = 0;
        let workedDates = [];
        let detailedShiftsText = '';
        const detailedShifts = getDetailedShifts(startInput, endInput);

        detailedShifts.forEach(s => {
            if (s.totalHours > 0) {
                totalWorkDays++;
                totalHours += s.totalHours;
                workedDates.push(new Date(s.date).getTime());
                detailedShiftsText += `${s.date}: ${s.shiftType === 'big' ? 'å¤§å¤œç­' : s.shiftType === 'small' ? 'å°å¤œç­' : 'è‡ªå®šä¹‰'} ${s.totalHours.toFixed(1)}h\n`;
            }
            if (s.shiftType === 'big') bigCount++;
            else if (s.shiftType === 'small') smallCount++;
            else if (s.shiftType === 'custom') customCount++;
        });

        let maxConsecutive = 0;
        let currentConsecutive = 0;
        workedDates.sort();
        for (let i = 0; i < workedDates.length; i++) {
            if (i === 0) {
                currentConsecutive = 1;
            } else {
                const dayBefore = new Date(workedDates[i - 1]);
                dayBefore.setDate(dayBefore.getDate() + 1);
                const currentDay = new Date(workedDates[i]);
                if (dayBefore.toISOString().split('T')[0] === currentDay.toISOString().split('T')[0]) {
                    currentConsecutive++;
                } else {
                    currentConsecutive = 1;
                }
            }
            maxConsecutive = Math.max(maxConsecutive, currentConsecutive);
        }

        let complianceViolations = 0;
        const totalDays = Math.ceil((endDate - startDate) / (1000 * 60 * 60 * 24)) + 1;
        for (let i = 0; i <= totalDays - 7; i++) {
            let weekTotal = 0;
            for (let j = 0; j < 7; j++) {
                const d = new Date(startDate);
                d.setDate(d.getDate() + i + j);
                weekTotal += getDailyHours(d.toISOString().split('T')[0]);
            }
            if (weekTotal > settings.limit) complianceViolations++;
        }

        const avgMonthlyHours = totalHours > 0 ? (totalHours / allMonths.length).toFixed(1) : 0;
        const avgDailyHours = totalWorkDays > 0 ? (totalHours / totalWorkDays).toFixed(1) : 0;
        const dateRange = `${startInput} è‡³ ${endInput}`;

        const summaryStats = {
            dateRange: dateRange,
            totalHours: parseFloat(totalHours.toFixed(1)),
            totalWorkDays: totalWorkDays,
            avgMonthlyHours: avgMonthlyHours,
            avgDailyHours: avgDailyHours,
            bigCount: bigCount,
            smallCount: smallCount,
            customCount: customCount,
            maxConsecutive: maxConsecutive,
            violationCount: complianceViolations,
            allMonths: allMonths,
            detailedShiftsText: detailedShiftsText
        };
        
        return { summaryStats };
    }


    function calculateStatsForRange() {
      const result = generateAnalysisData();
      if (result.error) {
        alert('é”™è¯¯ï¼š' + result.error);
        return null;
      }
      currentStatsSummary = result.summaryStats;
      return currentStatsSummary;
    }

    function renderStatsWithRange() {
      const stats = calculateStatsForRange();
      if (!stats) return;

      const aiResultStatusEl = document.getElementById('aiSummaryResultStatus');
      
      const { 
          dateRange, totalHours, totalWorkDays, avgMonthlyHours, avgDailyHours, 
          bigCount, smallCount, customCount, maxConsecutive, violationCount, allMonths 
      } = currentStatsSummary;

      const statsArray = [
          { label: 'ç»Ÿè®¡æ—¶é—´æ®µ', value: dateRange },
          { label: 'æ€»å·¥æ—¶', value: `${totalHours} å°æ—¶` },
          { label: 'å¹³å‡æ¯æœˆå·¥æ—¶', value: `${avgMonthlyHours} å°æ—¶` },
          { label: 'å·¥ä½œå¤©æ•°', value: `${totalWorkDays} å¤©` },
          { label: 'å¹³å‡æ¯æ—¥å·¥æ—¶', value: `${avgDailyHours} å°æ—¶` },
          { label: 'å¤§å¤œç­æ¬¡æ•°', value: `${bigCount} æ¬¡` },
          { label: 'å°å¤œç­æ¬¡æ•°', value: `${smallCount} æ¬¡` },
          { label: 'è‡ªå®šä¹‰/é¢å¤–ç­æ¬¡', value: `${customCount} æ¬¡` },
          { label: 'æœ€é•¿è¿ç»­å·¥ä½œ', value: `${maxConsecutive} å¤©` },
          { label: `è¿ç»­7å¤©è¶…é™æ¬¡æ•° (é™${settings.limit}h)`, value: `${violationCount} æ¬¡`, isViolation: violationCount > 0 },
      ];

      let html = '';
      statsArray.forEach(stat => {
        const cls = stat.isViolation ? 'warn' : '';
        html += `<div class="stat-item ${cls}"><label>${stat.label}</label><div class="stat-value">${stat.value}</div></div>`;
      });

      document.getElementById('statsGrid').innerHTML = html;
      renderMonthlyHoursChart(allMonths, currentStatsSummary.dateRange.split(' è‡³ ')[0], currentStatsSummary.dateRange.split(' è‡³ ')[1]);
      aiResultStatusEl.textContent = 'âœ… æ•°æ®åˆ†æå·²å®Œæˆã€‚ç‚¹å‡» "å¯åŠ¨ AI æ€»ç»“" æŒ‰é’®å¼€å§‹å¯¹è¯ã€‚';
      
      resetPanelChat('stats', aiResultStatusEl.textContent);
    }

    function renderMonthlyHoursChart(months, start, end) {
      if (chartInstance) chartInstance.destroy();
      const chartEl = document.getElementById('monthlyChart');
      if (!chartEl) return;
      
      const monthData = months.map(monthStr => {
          let monthTotalHours = 0;
          let monthWorkDays = 0;
          const [year, monthIndex] = monthStr.split('-').map(Number);
          const lastDay = new Date(year, monthIndex, 0).getDate();
          
          for (let i = 1; i <= lastDay; i++) {
              const dateStr = `${monthStr}-${String(i).padStart(2, '0')}`;
              const shift = shifts[dateStr];
              const hours = getDailyHours(dateStr);
              if (hours > 0) {
                  monthTotalHours += hours;
                  monthWorkDays++;
              }
          }
          return { month: monthStr, hours: parseFloat(monthTotalHours.toFixed(1)), days: monthWorkDays };
      });
      
      const labels = monthData.map(d => d.month);
      const hoursData = monthData.map(d => d.hours);
      const daysData = monthData.map(d => d.days);

      chartInstance = new Chart(chartEl, {
          type: 'bar',
          data: {
              labels: labels,
              datasets: [{
                  label: 'æ€»å·¥æ—¶ (å°æ—¶)',
                  data: hoursData,
                  backgroundColor: 'rgba(24, 144, 255, 0.6)',
                  borderColor: 'rgba(24, 144, 255, 1)',
                  borderWidth: 1,
                  yAxisID: 'y'
              }, {
                  label: 'å·¥ä½œå¤©æ•° (å¤©)',
                  data: daysData,
                  backgroundColor: 'rgba(82, 196, 26, 0.6)',
                  borderColor: 'rgba(82, 196, 26, 1)',
                  borderWidth: 1,
                  type: 'line',
                  fill: false,
                  yAxisID: 'y1'
              }]
          },
          options: {
              responsive: true,
              maintainAspectRatio: false,
              scales: {
                  y: {
                      type: 'linear',
                      display: true,
                      position: 'left',
                      title: {
                          display: true,
                          text: 'å·¥æ—¶ (å°æ—¶)'
                      },
                      grid: {
                          drawOnChartArea: true
                      }
                  },
                  y1: {
                      type: 'linear',
                      display: true,
                      position: 'right',
                      title: {
                          display: true,
                          text: 'å·¥ä½œå¤©æ•° (å¤©)'
                      },
                      grid: {
                          drawOnChartArea: false
                      }
                  }
              },
              plugins: {
                  legend: {
                      position: 'top'
                  },
                  title: {
                      display: true,
                      text: `æ¯æœˆå·¥æ—¶ä¸å¤©æ•°æ¦‚è§ˆ (${start} - ${end})`
                  }
              }
          }
      });
    }


    // ========== AI æ ¸å¿ƒè°ƒç”¨å‡½æ•° ========== 

    async function runChatCompletion(messages, endpoint, apiKey, model, isStreaming = false, chunkCallback = null) {
        if (!endpoint || !apiKey) {
            throw new Error("AI æœåŠ¡ç»ˆç«¯ç‚¹æˆ– API å¯†é’¥æœªé…ç½®ã€‚");
        }

        try {
            const response = await fetch(endpoint, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'Authorization': `Bearer ${apiKey}`
                },
                body: JSON.stringify({
                    model: model,
                    messages: messages, 
                    stream: isStreaming
                })
            });

            if (!response.ok) {
                const errorText = await response.text();
                throw new Error(`API è°ƒç”¨å¤±è´¥ [${response.status}]: ${errorText.substring(0, 100)}...`);
            }
            
            if (isStreaming) {
                if (!response.body) throw new Error("APIå“åº”æ²¡æœ‰æ­£æ–‡ï¼ˆå¯èƒ½ä¸æ”¯æŒæµå¼ä¼ è¾“ï¼‰ã€‚");
                const reader = response.body.getReader();
                const decoder = new TextDecoder("utf-8");
                let fullText = "";
                let buffer = "";

                try {
                    while (true) {
                        const { done, value } = await reader.read();
                        if (done) break;
                        buffer += decoder.decode(value, { stream: true });
                        let lines = buffer.split('\n');
                        buffer = lines.pop();

                        for (const line of lines) {
                            const trimmedLine = line.trim();
                            if (!trimmedLine || trimmedLine === 'data: [DONE]') continue;

                            try {
                                const json = JSON.parse(trimmedLine.substring(5));
                                const content = json.choices[0].delta.content || "";
                                fullText += content;
                                if (content && chunkCallback) {
                                    chunkCallback(content);
                                }
                            } catch (e) {
                                // Ignore json parsing errors for incomplete chunks
                            }
                        }
                    }
                    if (buffer && buffer !== 'data: [DONE]') {
                         const json = JSON.parse(buffer.substring(5));
                         const content = json.choices[0].delta.content || "";
                         fullText += content;
                         if (content && chunkCallback) {
                             chunkCallback(content);
                         }
                    }
                    return fullText;

                } catch (e) {
                    console.error("æµå¼è¯»å–é”™è¯¯:", e);
                    throw e;
                }
            } else {
                 const json = await response.json();
                 return json.choices[0].message.content;
            }

        } catch (error) {
            console.error('API Error:', error);
            throw error;
        }
    }


    // ========== AI é€šç”¨æœåŠ¡å‡½æ•° ========== 
    const isStreaming = true;
    const panelChatHistory = { calendar: [], stats: [] };
    const isPanelTyping = { calendar: false, stats: false };
    const panelContexts = { calendar: { system: '', data: '' }, stats: { system: '', data: '' } };

    function getPanelChatElements(panelId) {
        return {
            historyEl: document.getElementById(`${panelId}ChatHistory`),
            inputEl: document.getElementById(`${panelId}ChatInput`),
            inputContainerEl: document.getElementById(`${panelId}ChatInputContainer`),
            statusEl: document.getElementById(panelId === 'calendar' ? 'complianceAdviceStatus' : 'aiSummaryResultStatus'),
            sendBtn: document.querySelector(`#${panelId}ChatInputContainer button`)
        };
    }

    // ç¡®ä¿èŠå¤©è®°å½•å‚ç›´å †å 
    function displayPanelMessage(panelId, role, content, save = true) {
      const { historyEl } = getPanelChatElements(panelId);
      if (!historyEl) return;
      
      historyEl.classList.add('visible'); 

      const msgDiv = document.createElement('div');
      msgDiv.className = 'chat-message ' + (role === 'user' ? 'chat-user' : 'chat-ai');
      const formattedContent = content
        .replace(/```(.*?)\n([\s\S]*?)```/gs, (match, lang, code) => {
          return `<pre><code>${code.trim()}</code></pre>`;
        })
        .replace(/\n/g, '<br>');
      msgDiv.innerHTML = formattedContent;
      historyEl.appendChild(msgDiv);
      historyEl.scrollTop = historyEl.scrollHeight;

      if (save && role !== 'system') {
        panelChatHistory[panelId].push({ role, content });
      }
    }

    // é‡ç½®æ—¶ç§»é™¤ visible ç±»
    function resetPanelChat(panelId, initialMessage = null) {
      const { historyEl, inputContainerEl, statusEl } = getPanelChatElements(panelId);
      panelChatHistory[panelId] = [];
      isPanelTyping[panelId] = false;
      if (historyEl) {
        historyEl.innerHTML = '';
        historyEl.classList.remove('visible'); // ç§»é™¤ visible ç±»
      }
      if (statusEl) {
          statusEl.style.display = 'block';
          if (initialMessage) statusEl.textContent = initialMessage;
      }
      if (inputContainerEl) inputContainerEl.style.display = 'none';
    }

    // å°†ç³»ç»Ÿæ¶ˆæ¯å’Œä¸Šä¸‹æ–‡æ•°æ®åˆå¹¶æˆä¸€ä¸ª system æ¶ˆæ¯
    async function sendPanelChatMessage(panelId, initialPrompt = null) {
      const { inputEl, inputContainerEl, statusEl, historyEl, sendBtn } = getPanelChatElements(panelId);
      const userMessage = initialPrompt || inputEl.value.trim();
      if (!userMessage && !initialPrompt) return;
      if (isPanelTyping[panelId]) return;

      if (!settings.aiEndpoint || !settings.aiApiKey) {
        displayPanelMessage(panelId, 'ai', 'âŒ é”™è¯¯ï¼šè¯·åœ¨â€œè®¾ç½®â€ä¸­é…ç½® AI æœåŠ¡ç»ˆç«¯ç‚¹å’Œ API å¯†é’¥ã€‚', false);
        return;
      }
      
      if (statusEl) statusEl.style.display = 'none';
      historyEl.classList.add('visible'); // ç¡®ä¿å¯è§ä¸”å‚ç›´
      inputContainerEl.style.display = 'flex';

      if (!initialPrompt) {
          displayPanelMessage(panelId, 'user', userMessage);
          inputEl.value = '';
          inputEl.style.height = 'auto';
      }

      isPanelTyping[panelId] = true;
      inputEl.disabled = true;
      sendBtn.disabled = true;

      // ä¿®å¤ï¼šåˆå¹¶ç³»ç»Ÿæç¤ºå’Œä¸Šä¸‹æ–‡æ•°æ®
      const combinedSystemContent = `${panelContexts[panelId].system}\n\nã€æ’ç­æ•°æ®/èƒŒæ™¯ä¿¡æ¯ã€‘\n${panelContexts[panelId].data}`;
      const combinedSystemMessage = { role: 'system', content: combinedSystemContent };
      const userPromptMessage = { role: 'user', content: userMessage };

      // æ„é€  API è¯·æ±‚çš„ messages æ•°ç»„ï¼š[åˆå¹¶çš„System, ...å†å²è®°å½•, UserPrompt]
      let messages = [combinedSystemMessage, ...panelChatHistory[panelId].filter(m => m.role !== 'system'), userPromptMessage];

      const aiMessageEl = document.createElement('div');
      aiMessageEl.className = 'chat-message chat-ai';
      aiMessageEl.innerHTML = 'AI æ­£åœ¨æ€è€ƒ...';
      historyEl.appendChild(aiMessageEl);
      historyEl.scrollTop = historyEl.scrollHeight;

      try {
        const fullResponse = await runChatCompletion( 
            messages, 
            settings.aiEndpoint, 
            settings.aiApiKey, 
            settings.aiModel, 
            true, 
            (chunk) => {
              if (aiMessageEl.textContent === 'AI æ­£åœ¨æ€è€ƒ...') {
                  aiMessageEl.textContent = '';
                  aiMessageEl.innerHTML = '';
              }
              aiMessageEl.innerHTML += chunk.replace(/\n/g, '<br>');
              aiMessageEl.scrollTop = aiMessageEl.scrollHeight;
            }
        );
        
        // Final format of the full response after streaming
        aiMessageEl.innerHTML = fullResponse
             .replace(/```(.*?)\n([\s\S]*?)```/gs, (match, lang, code) => {
                return `<pre><code>${code.trim()}</code></pre>`;
             })
             .replace(/\n/g, '<br>');

        panelChatHistory[panelId].push({ role: 'ai', content: fullResponse });

      } catch (error) {
        console.error('API Error:', error);
        aiMessageEl.innerHTML = `âŒ API è°ƒç”¨å¤±è´¥: ${error.message}`.replace(/\n/g, '<br>');
      } finally {
        isPanelTyping[panelId] = false;
        inputEl.disabled = false;
        sendBtn.disabled = false;
        inputEl.style.height = 'auto';
      }
    }

    function handlePanelChatInput(event, panelId) {
      const inputEl = document.getElementById(`${panelId}ChatInput`);
      inputEl.style.height = 'auto';
      inputEl.style.height = inputEl.scrollHeight + 'px';
      if (event.key === 'Enter' && !event.shiftKey) {
        event.preventDefault();
        sendPanelChatMessage(panelId);
      }
    }

    // ========== Calendar AI é€»è¾‘ (å¯åŠ¨å¯¹è¯) ========== 
    async function runCalendarAiAnalysis() {
      // ... (ä»£ç é€»è¾‘ä¸å˜) ...
      const panelId = 'calendar';
      const { statusEl } = getPanelChatElements(panelId);
      if (!settings.aiEndpoint || !settings.aiApiKey) {
        resetPanelChat(panelId, 'âŒ é”™è¯¯ï¼šè¯·åœ¨â€œè®¾ç½®â€ä¸­é…ç½® AI æœåŠ¡ç»ˆç«¯ç‚¹å’Œ API å¯†é’¥ã€‚');
        return;
      }

      const violations = weekSummaries.filter(w => w.violation);
      if (violations.length === 0) {
        const msg = `âœ… AI åˆ†æï¼šæœ¬æœˆæ’ç­å®Œå…¨ç¬¦åˆè¿ç»­7å¤©å·¥æ—¶ä¸è¶…è¿‡ ${settings.limit} å°æ—¶çš„è§„å®šã€‚ä¸éœ€è¦æ¢ç­æˆ–è°ƒæ•´ã€‚`;
        resetPanelChat(panelId, msg);
        return;
      }

      // æ„å»ºç³»ç»Ÿå’Œä¸Šä¸‹æ–‡
      const violationDetails = violations.map(w => `\n- ${w.start} to ${w.end}: ${w.total.toFixed(2)} å°æ—¶ (è¶…é™ ${ (w.total - settings.limit).toFixed(2) } å°æ—¶)`).join('');
      const currentMonthShifts = getDetailedShifts(`${selectedMonth}-01`, new Date(selectedMonth.split('-')[0], selectedMonth.split('-')[1], 0).toISOString().split('T')[0]);
      const shiftDetails = currentMonthShifts.map(s => {
          if (s.shiftType === 'big') return `${s.date}: å¤§å¤œç­ (å«æ¬¡æ—¥) æ€»${s.totalHours.toFixed(1)}h`;
          if (s.shiftType === 'small') return `${s.date}: å°å¤œç­ æ€»${s.totalHours.toFixed(1)}h`;
          if (s.shiftType === 'custom') return `${s.date}: è‡ªå®šä¹‰ç­æ¬¡ æ€»${s.totalHours.toFixed(1)}h`;
          return null;
      }).filter(Boolean).join('; ');

      const contextData = `
        å½“å‰åˆ†ææœˆä»½ä¸º ${selectedMonth}ã€‚
        è§„åˆ™é™åˆ¶ï¼šè¿ç»­7å¤©å·¥æ—¶ä¸å¾—è¶…è¿‡ ${settings.limit} å°æ—¶ã€‚
        --- æ£€æµ‹åˆ°çš„è¿è§„è½®æ¬¡ ---
        å…±å‘ç° ${violations.length} æ¬¡è¶…é™ï¼š${violationDetails}
        --- æœ¬æœˆæ’ç­è®°å½•æ‘˜è¦ (ä»…ä¾›å‚è€ƒ) ---
        ${shiftDetails}
      `;
      
      panelContexts[panelId].system = `ä½ æ˜¯ä¸€ä¸ªä¸“ä¸šçš„å¤œç­å·¥æ—¶åˆè§„æ”¹è¿›é¡¾é—®ã€‚ä½ çš„å”¯ä¸€ä»»åŠ¡æ˜¯æ ¹æ®ç”¨æˆ·æä¾›çš„è¿è§„æ’ç­è®°å½•ï¼Œæå‡º**å…·ä½“çš„ã€å¯æ“ä½œçš„**ä¿®æ”¹å»ºè®®ï¼Œä»¥æ¶ˆé™¤æ‰€æœ‰è¶…é™è½®æ¬¡ï¼Œå¹¶å°½é‡ä¿æŒåŸæ’ç­çš„å®Œæ•´æ€§ã€‚å»ºè®®åº”ä»¥**æ¸…æ™°çš„æ­¥éª¤**ï¼ˆä¾‹å¦‚ï¼šå°†Xæ—¥çš„ç­æ¬¡è°ƒæ•´ä¸ºä¼‘æ¯ï¼Œå°†Yæ—¥è°ƒæ•´ä¸ºZç­æ¬¡ï¼‰ç»™å‡ºã€‚`;
      panelContexts[panelId].data = contextData;

      // åˆå§‹æé—®
      const initialPrompt = `è¯·æ ¹æ®ä»¥ä¸Šè¿è§„æƒ…å†µï¼Œæä¾›ä¸€ä¸ªä¿®æ”¹æ’ç­çš„å»ºè®®æ–¹æ¡ˆï¼Œä»¥ç¡®ä¿æ‰€æœ‰è¿ç»­7å¤©å·¥æ—¶ä¸è¶…é™ã€‚`;

      // é‡ç½®å¹¶å¯åŠ¨å¯¹è¯
      resetPanelChat(panelId);
      displayPanelMessage(panelId, 'user', `è¯·æ±‚æ’ç­ä¿®æ”¹å»ºè®®ï¼ˆåŸºäº ${violations.length} æ¬¡è¶…é™ï¼‰ã€‚æ•°æ®å·²æäº¤ç»™ AIã€‚`);
      sendPanelChatMessage(panelId, initialPrompt);
    }

    // ========== Stats AI é€»è¾‘ (å¯åŠ¨å¯¹è¯) ========== 
    async function runAiAnalysis() {
      // ... (ä»£ç é€»è¾‘ä¸å˜) ...
      const panelId = 'stats';
      if (!settings.aiEndpoint || !settings.aiApiKey) {
        resetPanelChat(panelId, 'âŒ é”™è¯¯ï¼šè¯·åœ¨â€œè®¾ç½®â€ä¸­é…ç½® AI æœåŠ¡ç»ˆç«¯ç‚¹å’Œ API å¯†é’¥ã€‚');
        return;
      }

      const data = generateAnalysisData();
      if (data.error) {
        resetPanelChat(panelId, `âŒ é”™è¯¯ï¼š${data.error}`);
        return;
      }

      // æ„å»ºç³»ç»Ÿå’Œä¸Šä¸‹æ–‡
      const { 
          dateRange, totalHours, totalWorkDays, avgMonthlyHours, avgDailyHours, 
          bigCount, smallCount, customCount, maxConsecutive, violationCount, detailedShiftsText 
      } = data.summaryStats;

      const contextData = `
        ç”¨æˆ·åœ¨ ${dateRange} æœŸé—´çš„æ’ç­è®°å½•å’Œç»Ÿè®¡æ‘˜è¦ï¼š
        --- ç»Ÿè®¡æ‘˜è¦ ---
        - æ€»å·¥æ—¶: ${totalHours} å°æ—¶
        - æ€»å·¥ä½œå¤©æ•°: ${totalWorkDays} å¤©
        - æœ€å¤§è¿ç»­å·¥ä½œå¤©æ•°: ${maxConsecutive} å¤©
        - å¤§å¤œç­æ¬¡æ•°: ${bigCount} æ¬¡
        - å°å¤œç­æ¬¡æ•°: ${smallCount} æ¬¡
        - å¹³å‡æ¯æœˆå·¥æ—¶: ${avgMonthlyHours} å°æ—¶
        - è¿ç»­7å¤©å·¥æ—¶è¶…é™æ¬¡æ•°: ${violationCount} æ¬¡ (è§„åˆ™é™åˆ¶ ${settings.limit} å°æ—¶)
        --- è¯¦ç»†æ’ç­æ•°æ® ---
        ${detailedShiftsText}
      `;
      
      panelContexts[panelId].system = `ä½ æ˜¯ä¸€ä½ä¸“ä¸šçš„ä¸ªäººå¥åº·ä¸ç”Ÿæ´»è§„åˆ’å¸ˆã€‚ä½ çš„ä»»åŠ¡æ˜¯åŸºäºç”¨æˆ·æä¾›çš„æ’ç­è®°å½•ï¼Œåˆ†æå…¶å·¥ä½œå¼ºåº¦å’Œå¤œç­é¢‘ç‡ï¼Œå¹¶æä¾›**äººæ€§åŒ–çš„ã€å…³æ€€å¤‡è‡³çš„ç”Ÿæ´»å»ºè®®**ã€‚è¯·**é¿å…**æä¾›ç”¨æˆ·æ— æ³•å®æ–½çš„â€œè°ƒæ•´æ’ç­â€æˆ–â€œä¿®æ”¹åˆ¶åº¦â€çš„å»ºè®®ï¼Œé‡ç‚¹åœ¨äºç”¨æˆ·å¯ä»¥**è‡ªæˆ‘ç®¡ç†**çš„éƒ¨åˆ†ï¼ˆå¦‚ä¼‘æ¯æ—¶é—´å®‰æ’ã€å¥åº·é¥®é£Ÿã€åº”å¯¹ç–²åŠ³ã€ç¤¾äº¤æ´»åŠ¨å®‰æ’ç­‰ï¼‰ã€‚`;
      panelContexts[panelId].data = contextData;

      // åˆå§‹æé—®
      const initialPrompt = `è¯·ä½ æ ¹æ®è¿™äº›ä¿¡æ¯ï¼Œæä¾›ä¸€ä»½ä¸“ä¸šçš„é•¿æœŸå¥åº·ä¸ç”Ÿæ´»å¹³è¡¡åˆ†ææ€»ç»“ã€‚è¯·ç”¨ä¸­æ–‡åˆ†ç‚¹æ€»ç»“ï¼š\n1. **å·¥ä½œèŠ‚å¥ä¸å¼ºåº¦è¯„ä¼°**ï¼›\n2. **ç”Ÿæ´»è´¨é‡é£é™©æç¤º**ï¼›\n3. **äººæ€§åŒ–å»ºè®®ï¼ˆè‡ªæˆ‘ç®¡ç†ï¼‰**ã€‚`;

      // é‡ç½®å¹¶å¯åŠ¨å¯¹è¯
      resetPanelChat(panelId);
      displayPanelMessage(panelId, 'user', `ç»Ÿè®¡åˆ†ææ‘˜è¦è¯·æ±‚ï¼ˆèŒƒå›´ï¼š${dateRange}ï¼‰ã€‚æ•°æ®å·²æäº¤ç»™ AIã€‚`);
      sendPanelChatMessage(panelId, initialPrompt);
    }

    // ========== AI å¯¹è¯é€»è¾‘ (Chat é¢æ¿) - ä¿®å¤ System æ¶ˆæ¯åˆå¹¶ ========== 
    
    class AIAssistant {
      static history = [];
      static isTyping = false;
      static historyEl = document.getElementById('chatHistory');
      static chatInputEl = document.getElementById('chatInput');
      static systemMessage = { role: 'system', content: '' };
      static contextData = ''; // ç”¨äºå­˜å‚¨åˆ†ææ’ç­æ•°æ®

      static initSystemMessage() {
          this.systemMessage = { role: 'system', content: `ä½ æ˜¯ä¸€ä½ä¸“ä¸šä¸”å……æ»¡äººæƒ…å‘³çš„ç§äººå¥åº·åŠ©æ‰‹ã€‚ä½ çš„ä»»åŠ¡æ˜¯åŸºäºç”¨æˆ·æä¾›çš„æ’ç­ã€å·¥æ—¶æ•°æ®ï¼Œå›ç­”å…³äºå¤œç­å·¥ä½œä¸‹çš„å¥åº·ã€æƒ…ç»ªå’Œç”Ÿæ´»è´¨é‡çš„é€šç”¨é—®é¢˜ã€‚è¯·ä»¥äº²åˆ‡ã€å…³æ€€çš„å£å»å›ç­”ï¼Œå¹¶æä¾›**ç§¯æä¸”å®ç”¨çš„ä¸ªäººç”Ÿæ´»å»ºè®®**ï¼ˆå¦‚ç¡çœ ä¼˜åŒ–ã€é¥®é£Ÿã€è¿åŠ¨ã€æƒ…ç»ªè°ƒèŠ‚ç­‰ï¼‰ã€‚ä½ ä¸èƒ½ç›´æ¥ä¿®æ”¹æ’ç­æ•°æ®ã€‚` };
          this.contextData = ''; // åˆå§‹åŒ–æ—¶æ¸…ç©ºä¸Šä¸‹æ–‡æ•°æ®
      }

      static updateChatConfigStatus() {
          const statusEl = document.getElementById('chatConfigStatus');
          if (settings.aiEndpoint && settings.aiApiKey) {
              statusEl.textContent = ` (AIæœåŠ¡: ${settings.aiModel}, å·²è¿æ¥)`;
              statusEl.style.color = '#52c41a';
          } else {
              statusEl.textContent = ' (AIæœåŠ¡æœªé…ç½®ï¼Œè¯·åˆ°â€œè®¾ç½®â€ä¸­é…ç½® API å¯†é’¥)';
              statusEl.style.color = '#ff4d4f';
          }
      }

      static displayMessage(role, content, save = true) {
          const msgDiv = document.createElement('div');
          msgDiv.className = 'chat-message ' + (role === 'user' ? 'chat-user' : 'chat-ai');
          const formattedContent = content
               .replace(/```(.*?)\n([\s\S]*?)```/gs, (match, lang, code) => {
                  return `<pre><code>${code.trim()}</code></pre>`;
               })
               .replace(/\n/g, '<br>');
          msgDiv.innerHTML = formattedContent;
          this.historyEl.appendChild(msgDiv);
          this.historyEl.scrollTop = this.historyEl.scrollHeight;

          if (save && role !== 'system') {
              this.history.push({ role, content });
          }
      }

      static displayChunk(content) {
          const historyEl = AIAssistant.historyEl;
          let lastMessage = historyEl.lastChild;
          
          if (!lastMessage || !lastMessage.classList.contains('chat-ai')) {
              lastMessage = document.createElement('div');
              lastMessage.className = 'chat-message chat-ai';
              historyEl.appendChild(lastMessage);
          }
          
          const formattedContent = content
               .replace(/```(.*?)\n([\s\S]*?)```/gs, (match, lang, code) => {
                    // This block should handle the final formatting correctly by replacing the streaming output.
                    return `<pre><code>${code.trim()}</code></pre>`;
               })
               .replace(/\n/g, '<br>');

          // Since we are streaming, we append the raw chunk content here, which may contain partial markdown/html
          // The final message formatting in sendMessage will clean this up.
          lastMessage.innerHTML += content.replace(/\n/g, '<br>');
          historyEl.scrollTop = historyEl.scrollHeight;
      }
      
      static async sendMessage(userMessage) {
        if (this.isTyping) return;
        this.isTyping = true;

        this.displayMessage('user', userMessage);
        this.chatInputEl.value = '';
        this.chatInputEl.disabled = true;
        document.getElementById('chatSendBtn').disabled = true;
        
        // ä¿®å¤ï¼šåˆå¹¶ç³»ç»Ÿæ¶ˆæ¯å’Œä¸Šä¸‹æ–‡æ•°æ®
        let finalSystemContent = this.systemMessage.content;
        if (this.contextData) {
            finalSystemContent = `${this.systemMessage.content}\n\n${this.contextData}`;
        }
        const finalSystemMessage = { role: 'system', content: finalSystemContent };
        const messages = [finalSystemMessage, ...this.history];


        let finalResponse = '';
        let isError = false;

        try {
            // Display initial AI thinking message before streaming starts
            const aiMessageEl = document.createElement('div');
            aiMessageEl.className = 'chat-message chat-ai';
            aiMessageEl.innerHTML = 'AI æ­£åœ¨æ€è€ƒ...';
            this.historyEl.appendChild(aiMessageEl);
            this.historyEl.scrollTop = this.historyEl.scrollHeight;

            finalResponse = await runChatCompletion( 
                messages, 
                settings.aiEndpoint, 
                settings.aiApiKey, 
                settings.aiModel, 
                isStreaming, 
                (chunk) => {
                   if (aiMessageEl.textContent === 'AI æ­£åœ¨æ€è€ƒ...') {
                       aiMessageEl.textContent = '';
                       aiMessageEl.innerHTML = '';
                   }
                   aiMessageEl.innerHTML += chunk.replace(/\n/g, '<br>'); 
                   aiMessageEl.scrollTop = aiMessageEl.scrollHeight;
                }
            );
        } catch (error) {
            isError = true;
            finalResponse = `âŒ API è°ƒç”¨å¤±è´¥: ${error.message}`;
        }
        
        // Finalize the last message's formatting after streaming is complete
        const lastMessage = this.historyEl.lastChild;
        if (lastMessage) {
            lastMessage.innerHTML = finalResponse
                 .replace(/```(.*?)\n([\s\S]*?)```/gs, (match, lang, code) => {
                    return `<pre><code>${code.trim()}</code></pre>`;
                 })
                 .replace(/\n/g, '<br>');
        }
        
        if (!isError) {
             this.history.push({ role: 'ai', content: finalResponse });
        } else {
             // If error, store the error message in history but not for context
             this.history.push({ role: 'ai', content: finalResponse }); 
        }
        
        this.isTyping = false;
        this.chatInputEl.disabled = false;
        document.getElementById('chatSendBtn').disabled = false;
        this.chatInputEl.style.height = 'auto';
      }

      static async analyzeShiftData() {
        if (AIAssistant.isTyping) return;
        
        const startInput = document.getElementById('chatStartDate').value;
        const endInput = document.getElementById('chatEndDate').value;
        
        if (!startInput || !endInput) {
          AIAssistant.displayMessage('ai', 'âŒ è¯·å…ˆåœ¨æ—¥æœŸè¾“å…¥æ¡†ä¸­é€‰æ‹©æœ‰æ•ˆçš„åˆ†ææ—¥æœŸèŒƒå›´ã€‚', false);
          return;
        }

        const detailedShifts = getDetailedShifts(startInput, endInput);

        if (detailedShifts.length === 0) {
          AIAssistant.displayMessage('ai', `âš ï¸ åœ¨ ${startInput} è‡³ ${endInput} èŒƒå›´å†…æœªæ‰¾åˆ°ä»»ä½•æ’ç­è®°å½•ã€‚è¯·æ£€æŸ¥æ‚¨é€‰æ‹©çš„æ—¥æœŸã€‚`, false);
          return;
        }

        const conciseShiftLines = detailedShifts.map(s => {
          let description = '';
          if (s.shiftType === 'big') description = `å¤§å¤œç­ (æœ¬æ—¥${s.raw.hours.toFixed(1)}h + æ¬¡æ—¥${settings.bigNext.toFixed(1)}h)`;
          else if (s.shiftType === 'small') description = `å°å¤œç­ (${s.totalHours.toFixed(1)}h)`;
          else if (s.shiftType === 'custom') description = `è‡ªå®šä¹‰ç­æ¬¡ (${s.totalHours.toFixed(1)}h)`;
          return `${s.date}: ${description}`;
        }).join('\n');

        // ä¿®å¤ï¼šå°†ä¸Šä¸‹æ–‡æ•°æ®å­˜å…¥ contextData å˜é‡
        AIAssistant.contextData = `
ã€æ’ç­åˆ†ææ•°æ®ã€‘
ç”¨æˆ·æä¾›çš„æ’ç­æ•°æ®èŒƒå›´ä¸º ${startInput} è‡³ ${endInput}ï¼Œå…·ä½“è®°å½•å¦‚ä¸‹ï¼š
${conciseShiftLines}`;
        
        AIAssistant.history = []; // æ¸…ç©ºç”¨æˆ·/AIå†å²è®°å½•

        AIAssistant.displayMessage('ai', `âœ… å·²æˆåŠŸè½½å…¥ ${startInput} è‡³ ${endInput} æœŸé—´çš„æ’ç­æ•°æ® (${detailedShifts.length} æ¡è®°å½•)ã€‚è¯·éšæ—¶æé—®ï¼`, false);
        
        const starterPrompt = `è¯·æ ¹æ®æˆ‘è½½å…¥çš„æ’ç­æ•°æ®ï¼Œæ€»ç»“æˆ‘çš„å¤œç­é¢‘ç‡å’Œå·¥ä½œå¼ºåº¦ï¼Œå¹¶ä¸ºæˆ‘æä¾›ä¸€ä»½å…³äºå¦‚ä½•è°ƒæ•´ä½œæ¯å’Œé¥®é£Ÿçš„å»ºè®®ã€‚`;
        AIAssistant.sendMessage(starterPrompt);
      }
    }
    
    // Global functions for chat
    function sendChatMessage() {
        const input = document.getElementById('chatInput');
        const message = input.value.trim();
        if (message) {
            AIAssistant.sendMessage(message);
        }
    }
    
    function resetChatHistory() {
        if (confirm('ç¡®å®šé‡ç½®å¯¹è¯å—ï¼Ÿæ’ç­åˆ†ææ•°æ®ä¹Ÿå°†è¢«æ¸…é™¤ã€‚')) {
             AIAssistant.history = [];
             AIAssistant.contextData = ''; // æ¸…é™¤ä¸Šä¸‹æ–‡æ•°æ®
             AIAssistant.initSystemMessage();
             AIAssistant.historyEl.innerHTML = '';
             AIAssistant.displayMessage('ai', 'å¯¹è¯å·²é‡ç½®ã€‚æ‚¨å¯ä»¥é‡æ–°é€‰æ‹©æ—¥æœŸèŒƒå›´å¹¶ç‚¹å‡»â€œè·å–å¹¶åˆ†ææ’ç­å¯¹å¥åº·çš„å½±å“â€ï¼Œæˆ–ç›´æ¥æé—®ã€‚', false);
        }
    }

    function handleChatInput(event) {
      const inputEl = document.getElementById('chatInput');
      inputEl.style.height = 'auto';
      inputEl.style.height = inputEl.scrollHeight + 'px';
      if (event.key === 'Enter' && !event.shiftKey) {
        event.preventDefault();
        sendChatMessage();
      }
    }
    
    // Helper function to initialize date inputs for stats/chat panels
    function initDateRangeForStats(forceRender = false) {
        const endDate = new Date();
        const startDate = new Date();
        startDate.setDate(endDate.getDate() - 30); // Default to last 30 days

        const format = (date) => date.toISOString().split('T')[0];
        
        const statStartEl = document.getElementById('statStartDate');
        const statEndEl = document.getElementById('statEndDate');
        
        if (!statStartEl.value) statStartEl.value = format(startDate);
        if (!statEndEl.value) statEndEl.value = format(endDate);
        
        if (forceRender) {
            renderStatsWithRange();
        }
    }
    
    function initDateRangeForChat() {
        const endDate = new Date();
        const startDate = new Date();
        startDate.setDate(endDate.getDate() - 30); // Default to last 30 days
        const format = (date) => date.toISOString().split('T')[0];

        const chatStartEl = document.getElementById('chatStartDate');
        const chatEndEl = document.getElementById('chatEndDate');

        if (!chatStartEl.value) chatStartEl.value = format(startDate);
        if (!chatEndEl.value) chatEndEl.value = format(endDate);
    }
    
    // Call load and render on window load
    window.onload = async () => {
      loadFromLocal();
      // Set default month input value
      document.getElementById('monthInput').value = selectedMonth || new Date().toISOString().slice(0, 7);
      
      AIAssistant.initSystemMessage();
      AIAssistant.updateChatConfigStatus();

      // åˆå§‹åŒ–æ‰€æœ‰é¢æ¿çš„èŠå¤©çŠ¶æ€
      resetPanelChat('calendar', 'ç‚¹å‡» "åˆ†æå¹¶æä¾›æ¢ç­å»ºè®®" å¯åŠ¨å¯¹è¯ã€‚');
      resetPanelChat('stats', 'è¯·å…ˆé€‰æ‹©æ—¥æœŸèŒƒå›´å¹¶ç‚¹å‡»â€œåˆ†æâ€ï¼Œç„¶åç‚¹å‡» "å¯åŠ¨ AI æ€»ç»“" å¯åŠ¨å¯¹è¯ã€‚');

      await loadFromCloud();
      renderCalendar();
      const defaultTab = settings.defaultView || document.querySelector('.nav-tabs button.active')?.id.replace('tab-', '') || 'calendar';
      switchTab(defaultTab);
      
      if (supabase) {
        const userId = getUserId();
        let lastSyncTimestamp = 0;
        const subscription = supabase
          .channel('shifts-channel')
          .on('postgres_changes', { event: '*', schema: 'public', table: 'shifts', filter: `user_id=eq.${userId}` }, async (payload) => {
            const now = Date.now();
            if (now - lastSyncTimestamp < 2000) return;
            lastSyncTimestamp = now;
            console.log('æ”¶åˆ°äº‘ç«¯ç­æ¬¡æ›´æ–°', payload.eventType);
            await loadFromCloud();
            renderCalendar();
          })
          .on('postgres_changes', { event: '*', schema: 'public', table: 'settings', filter: `user_id=eq.${userId}` }, async (payload) => {
            const now = Date.now();
            if (now - lastSyncTimestamp < 2000) return;
            lastSyncTimestamp = now;
            console.log('æ”¶åˆ°äº‘ç«¯è®¾ç½®æ›´æ–°', payload.eventType);
            await loadFromCloud();
            loadSettingsUI();
          })
          .subscribe((status) => { console.log('å®æ—¶è®¢é˜…çŠ¶æ€:', status); });
        
        window.supabaseSubscription = subscription;
      }
    };

    window.onclick = (e) => { 
        if (e.target.id === 'extraModal') closeExtraModal(); 
        if (e.target.id === 'contextMenu') document.getElementById('contextMenu').style.display = 'none';
        
        // If not in multi-select mode and a day cell is clicked, ensure context menu is hidden
        if (!isMultiSelectMode && !e.target.closest('.day-cell')) {
            clearSelected();
            updateShiftInfo(false);
        }
    };
  </script>
</body>
</html>
